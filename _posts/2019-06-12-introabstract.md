---
title: プログラム入門：抽象化の話
layout: page
---

プログラムの入門としての抽象化の話をします。ベテラン向けじゃないんで、ベテランの人は読んでも新しい事は無いと思います。

データ分析界隈だと、数学や物理などで抽象的な事というのには良く出会ってきた経験を持つので、抽象的な物は得意な方だ、という人は多いと思うし、実際そうだと思う。

ただ、プログラムの抽象化は違う部分もあるので、一度プログラムの抽象化という物を初心者の気持ちになって学んでみる機会は必要とも思う。
ここではそんな話をしてみる。

## カプセル化

プログラムの抽象化と言えばカプセル化なのだが、いまいち良い解説が無いので自分で書く事にする。

一般的な事は知らないけれど、プログラムにおいては、抽象化の定義は「情報を落とす」事となっている。
全ての情報を持っている所から、特定の情報だけにする事でアクセスする「口」を定める訳だ。

だからだいたいの抽象化は物を「削る」のだけど、一つだけ例外がある
それが「カプセル化」。カプセル化はプログラムにおいて特に重要な抽象化となる。

### カプセル化の定義

カプセル化とは、「複数の物をまとめて名前を付けて、その名前で一つの物として扱う事」というのが定義となる。
学術的なちゃんとした定義はどっかで調べてください。（ちょっとググったが手頃なのが見つからなかった）。

例えば構造体とかはカプセル化っぽい。以下みたいなの。

```
struct Polar {
    double r;
    double theta;
};
```

rとthetaという二つの浮動小数点変数を一つにまとめて、Polarという名前をつけている。

カプセル化が他の抽象化と違う所として、「新しいエンティティを生み出す」という所がある。
他の抽象化はだいたい削るのが基本なのだが、カプセル化だけは「生み出す」。

ただし抽象化の定義には合致していて、情報は捨てている。
エンティティの名前で呼んでいる時は、そのほかの二つのdoubleで表せる概念、例えば身長と体重の組では無くなっている。
もともとのdouble二つでは極座標でも身長と体重の組でもなんでも扱えるのだが、
Polarにした後はそういうなんでも扱える部分の一部だけに限定されて、極座標だけを扱う事になった。

関数を作るのもカプセル化といえる。

```
double average(double* vals, int len) {
    double sum = 0.0;
    for(int i = 0; i < len; i++) {
        sum += vals[i];
    }
    return sum/len;
}
```

複数の命令、forを回したり足し合わせたり長さで割ったり、といった命令をまとめて、averageという名前をつけている。
使う側はaverageという名前でこの命令全体を実行するのと同じ事が実行出来る。

複数の要素をまとめて一つの名前をつけて、その名前でもって一つのエンティティとして扱う事、これをカプセル化という。

### カプセル化とは概念を生み出す事

複数の物を集めて名前をつける、というのはあまりにも汎用的すぎて、入門のうちはその概念を改めて考えてみるご利益は少ないと思う。
ただプログラムを書くようになったら、どこかのタイミングで考えてみるに値する。

カプセル化、ひるがえってプログラムが特別な所は、概念を生み出す機会の多さにある。
数学でも変数はつけるので、概念を生み出している事もちょくちょくある。
ただ、プログラム的な意味で複雑な概念を生み出す機会は、新しい数学を作る時くらいしか無い。
そういう場はプログラム程は頻繁では無いと思う。

プログラムでは、新しい概念を生み出す事を日常的に行う。
だから数学等で抽象的な物になれていても、この概念を生み出す所の抽象化は少し初心者の気持ちになって学ぶ姿勢が必要な所と思う。

プログラムというのは、究極的には一番下の命令を羅列するだけで目的の挙動をさせる事は出来る。
だからプログラムの初期の段階では、解きたい問題に対して、その解法を記述する命令を羅列する、という活動となる。

プログラムを読む時も、最初のうちは命令列の羅列まで掘り下げていく事が読む事であり、
抽象を壊して全情報に戻す作業が理解する、という事になる。

だが、これは入門時だけの事で、一定以上の現実的なプログラミングにおいては、
それよりも抽象を構築する事の方がメインとなる。
その問題に合わせた「概念を生み出す」というのがプログラムの中心的活動、と言っても過言では無い。

理解をする時も、一番下の命令の羅列までブレークダウンするのでは無く、構築されている抽象を理解するように心がける。

プログラムをする時は、いつもこの概念を生み出す、という事について自覚的になって、
どういう概念を生み出すべきか？という風に考える必要がある。
概念を生み出す時には、いつもカプセル化がその主体となる。
数学とかをたくさん触ってきた人は特に、このカプセル化について改めて考えてみて、
プログラムを見直してみる価値があると思う。

## 抽象化の二面性

概念を生み出すのがプログラムの重要な特徴だが、この生み出した概念、
というのは、「そう考えてやる」事で初めて確固とした実在を得る。
逆にそう考えてやらないと、あまりちゃんとした概念として存在出来ない。

だいたいの抽象化には、二面性がある。
それは使う側と作る側だ。

感覚的には、水面に浮かんでいる葉っぱを地上から見るのと、水面の下から見る、という二つの見方があり、この二つの見方を「意図的に」切り替える必要がある。

先ほどの平均を求める関数を考えよう。

```
double average(double* vals, int len) {
    double sum = 0.0;
    for(int i = 0; i < len; i++) {
        sum += vals[i];
    }
    return sum/len;
}
```

### 使う側から見た抽象化

これは、使う側からは、以下のようなシグニチャで、

```
double average(double* vals, int len)
```

配列の平均を求めるようにふるまう、という風に考える。

実装がどうなっているか、という事は考えずに、提供する機能だけに注目してやる事が大切。
使う側からは「XXという名前でYYという機能を提供している」と、「何をしてくれるか」という視点で考えるのが大切。

中の実装も分かっているのだけど、あえてそこを使う側で考える時は「知らないフリ」をする。
この頭の切り替えがプログラムにおける抽象化の大切なポイント。
実装をあえて「忘れる」事で、提供している「何」に集中する。
この意識を集中させる事で、作った概念がより確固とした物になる。

この、実装をあえて「考えない」で、提供する「何」に着目するのは、出来るようになるべく意識して訓練する必要がある。（そんな難しくも無いけど）

これが水面の葉っぱを地上から見た場合。

### 作る側から見た抽象化

抽象化にはいつも二面性がある。使う側は既に述べた事だが、使う側から見る時は反対に頭を切り替えて、実装に着目する。

着目するのは、実装、つまり以下の所になる。

```
    double sum = 0.0;
    for(int i = 0; i < len; i++) {
        sum += vals[i];
    }
    return sum/len;
```

これこそがaverageという物だ、というのが、実装側から見た視点となる。
葉っぱを水の中から見上げるイメージ。

こちらの視点は初心者でも普通に持っている物なので難しい事は無い。
ただ、初心者はいつもこちらの視点を持ち続けてしまう。
プログラムにおける抽象化においては、こちらの視点は意図した時だけに限って、
その場合はこちらに集中する、というのが重要。

いつもなんとなく実装を思ってはいけない。あくまで「実装側から見るぞ！」と思った時だけ見る。
この見方を頻繁に切り替えて、両方一緒には見ないのが大切。

## 問題領域の言葉で問題を記述する

encapsulationで概念を作り出す事が大切で、その概念をはっきりした物とする為には使う側と作る側を意識してはっきり分けて考える事が大切、という話をした。
これで概念を作り出す事は出来るようになった。

次に、ではその作り出す能力を使って、「どういう概念を作るか？」という事を考えたい。

プログラムの基本としては、まず使う言葉を「問題領域の言葉」まで引き上げて、その問題領域の言葉で問題を記述する、というのがある。
この問題領域の言葉を作るのに「概念を作る」ということを使っていく。

### 問題領域の言葉の例

何が問題領域の言葉か、というのは明確な定義がある訳じゃないが、いくつかの例を挙げることは出来る。
そこからなんとなく感じ取ることは出来ると思うので、例を挙げていこう。

例えば「線形リストのある値のノードまでたどって、その一つ前のnextを新しく作ったノードに差し替えて、新しく作ったノードのnextを先程見つけたノードのnextに差し替える」という表現は、いかにも低レベルな表現だ。
これよりは、「新しくノードを作って、適切な場所に挿入する」の方が抽象度は高い。
さらにこれがスプレッドシートのアプリを作っているなら、「シートのある列の隣に、新しい列を挿入する」の方がよりスプレッドシート、という問題に近い。
この「シートのある列の隣に、新しい列を挿入する」が問題領域の言葉と言える。
「シート」、「列」、こうしたものは問題領域の言葉だ。
なるべくそういう言葉でコードを書く方が良い。

もう一つ例を挙げよう。
「HTTPのリクエストを投げて、結果のxmlのarticleという要素のtitleの一覧を集めて表示し、その表示のtagにはこのarticleのサブツリーをぶら下げておく」よりは、「最新の記事の一覧をリクエストし、記事の一覧のタイトルを表示する。tagには記事をぶら下げておく」の方がより問題領域の言葉に近い。
HTTPとかxmlとかそのelementの名前よりは、最新の記事とか記事の方がより問題領域の言葉に近い。

arrのposに値を代入してpos++するよりは、値をスタックにプッシュする方が問題領域の言葉にちょっと近い（問題に依るが）。
SQLにitemIdをキーにしてtagcloudのフィールドにtagidをもったレコードを追加するよりは、itemに対するタグを追加する、の方が良い。

問題領域とは、解こうとしている問題の言葉なので、解こうとしている問題によって何がより問題領域に近いか、は変わっていく。
ただ以上の例で雰囲気はわかると思う。

### 言葉を作る、という場合の言葉とは？

言葉というのは抽象的な言い方なのだが、これが抽象的な言い方がもっとも適切なので少し説明がわかりにくい部分もある。
例えば新しい問題領域用のプログラム言語を作るなら文法とか語彙が必要になり、いわゆるDSLを作る、という事になる。
一方で問題領域の言葉を作る、と言った場合、普通はDSLに限らずもっと単純なAPIとかも言葉とみなす。
そこで何を言葉とするかは曖昧なのだが、例を挙げてなんとなく空気を感じてもらおう。

もとの問題が大きなAという記述をされているとする。
これから一部を切り出してBという概念を作り、Aのコードを一部Bに切り出す。
で、AはBを使う形でA'という形に変える。

この時にBに対する操作というのが一番原始的な意味での言葉となる。
これだけでは言葉というにはあまりにもしょぼいのだけど、こうして登場キャラクターが増えてきて操作も増えていくと、割と立派な言葉に育っていく。

ただ、単に例えば関数とかクラスでは不十分な場合ももちろんあり、より言葉として複雑である方が望ましくなってくると、何らかの形のDSLを作る事も自然な延長としてありえる。
特に言語内で、ホスト言語と切り離したセマンティクスを与えやすい仕組みのある言語では、比較的一般的でもある。
C#のLinqやkotlinのtype safe builderなどはそうした問題領域の言葉をリッチにしやすい言語機能と言える。

抽象化という観点からすると、これらの問題はあまり本質的では無い。
より本質的には、あいまいな言い方になるが「言葉っぽいと感じられるのが言葉」ということになる。

### 言葉っぽいと感じるためのヒント

言葉を作っていく感覚を養うには、「言葉とはXXだ」という定義から始めるよりも、
どういう物を言葉っぽいと感じるかのヒントのようなところからはじめて、それを意識しつつ日々コーディングをしていく中で学んでいくのが良いと思う。

そこでいくつか、自分が言葉っぽいと感じる時に思う条件をつらつらと書いていく。

**抽象度が揃っている**

例えばバイト配列に対して値を吐き出していくEmitterというクラスがあるとしよう。

Emitterにemit_intがあるなら、emit_stringはあって良いと思う。
一方で、ldr命令のレジスタの場合を吐き出す、emit_ldr_registerはちょっと抽象度がずれているので同じ階層にあるべきでは無い。

Emitterが言葉的に思えるためには、そのメソッドの抽象度が揃っている方が良い。

**組み合わせに変な制約が無い**

問題をブレークダウンしていく過程でモジュール化が進むと、もともとはある関数Bは、別の関数Aのあとでしか呼ばれない、という場合がある。
こういう、言葉からは想像されない裏の条件があるのはあまり言葉っぽく無い。

ブレークダウンしていったもとの問題からは生まれないう組み合わせでも動く、というのは言葉っぽさを感じる瞬間だ。
もとの問題から離れても動く事で、抽象化の2つの視点、「使う側からの視点」がより強化される。

そのレイヤーの中の構成要素で自由に組み合わせを変えても字面の期待通りの振る舞いをする時、
これを言葉っぽいと感じる。

後述するボトムアップで作っていく場合、ここが一番重要なポイントと思う。

一方でどんな呼び方してもちゃんと動くように作る、というのは、必要無い制約を勝手に設けて問題を難しくしてしまう部分もあるので、ここはトレードオフ。ただ言葉っぽく感じるという観点からすれば、自由な組み合わせが許される方が良い。

**扱っている問題領域にそもそもそういう言葉がある**

これは結構重要で、今扱っている抽象度のレイヤがそもそもプログラムの外の世界にも存在していて、そこにそういう言葉がある場合、それは言葉っぽさを感じる。

例えばBankAccountにdepositとかwithdrawとかtransferがあると言葉っぽい。

いつもドメインの言葉をそのまま定義すれば良いとは限らないが、定義する事が出来てそれが良い抽象になりそうな時は積極的にやりたい。
この時はドメインの言葉で問題が書けるので、恩恵は大きい。


### 言葉をボトムアップで作るかトップダウンで作るか

問題領域の言葉というのは、普通作り始める段階では何が適切かはわかっていない。
それを知る、というのはプログラムというアクティビティの本質的な部分である。
そして何を作るかがわかっていないのだから、それをどう作るかも当然分かっていない。

さて、問題領域の言葉というのは、普通それ自体がほとんど答えに近い。
だから問題領域の言葉を作るのは、直接問題を解くのよりほんの少しマシなくらいしか簡単になってない。
だから問題領域の言葉を作るには、その下のサブ問題領域の言葉を作ることになる。
このサブ問題領域の言葉もだいたいは複雑なので、さらに下にサブサブ領域の言葉を作ることになる。

こうして、言葉はレイヤーになることが多い。

こうしたレイヤーを作っていくとき、普通問題領域のそばと、一番下の実装のそばのレイヤーはなんとなくわかることが多い（往々にして最終的には似ても似つかない物になりがちだが）。
問題領域の言葉は解こうとしている問題の世界で普通に出てくる物が多い。
実装の一つ上のレイヤーは、問題の解法を実装していこうとしたら必要になるutility関数のような物から始まりがちだ。

ということで、最初はこの上から作る向きと下から作る向きの両方を（交互に）考える感じになる。
まず、問題領域の言葉を考える。その言葉を表すインターフェースくらいをぼんやり決める。
ただ実装はまずはハリボテ。なんとなく問題をその言葉で記述する。

次に実装。必要な物を作るのに必要な物を一段くらい考える。その上に何が載るかは良く分からない。
こちらは割と具体的に作れるが、実は必要でない物を作ってしまうのが良くある。
そこで軽く必要そうな物を雑に作って、ハリボテな感じに一応つなげようとしてみる。
もちろん間が無いのできれいにはつながらないのだが、そのところで、上はもうちょっと下にこう降りていかないとだめだな、と気付き、下側のレイヤはもっと上にこういうのを足していかないとだめだな、と分かっていく。

この上と下の両方からちょっとずつ埋めていく。

プログラムの入門ではとりあえず実装をしてそれを整理していく、という形に進みがちだし、それはそれで良い事もあるが、このやり方は小さな問題でしか使えない。
より難しい問題を解くときには、よりしっかりとした抽象概念が必要で、それを作るには練習が要る。

### ボトムアップで言葉を作る利点と注意点

ボトムアップにプログラムを行うのは、言葉を作る、という考えをそのまま行っていくような形態になるので、
言葉、ひるがえってちゃんとしっかりした抽象を構築しやすいという利点がある。

ゲームを作る時に、まずベクトルのレイヤとして、スカラー倍、足し算、引き算、内積、絶対値、そのほか必要な物が揃い、その上でこのベクトルの言葉を使って頂点の集合や平面を記述し、
その幾何図形の言葉でキャラクターやフィールドを記述する、みたいな物。

こういう時に下のベクトルの部分では、そのレイヤーだけである程度は必要な物を知る事ができるし、
そのレイヤーができればそのレイヤーを使って上の実験をいろいろそのレイヤーの言葉で記述出来る。
トップダウンの何かは無くても下から試していける。

一方でボトムアップのやり方は、不要な機能を作るのに時間を掛けてしまう、という欠点もある。
実装は難しいが実際は要らなかった、とか、
ボトムアップから良く定義されたしっかりとした抽象が考えられたが、その抽象は上から見ると適切では無かった、などという場合も多い。

ここはやはりバランスが大切で、下から作っていく時のある程度のそのレイヤーとしての完成度と、
先に進んでいくための最低限のハリボテのバランスを取ってちょうど良いくらいのところまでやるのが腕の見せ所。

ただボトムアップで下の方をやっていく方が言葉は作りやすい気はする。

### 言葉っぽくするために良いように分割

問題AからBを切り出して、A'とBにするケースを考えよう。

あるコードAを切り分ける時に、どこをA'に残し、どこをBに移すか、というのを決める必要がある。
これを考えるのに、「それをBに足すのは、Bのドメインの言葉として適切か？」というのは重要な基準となる。
また、Bという物自体を考え出すのにも、それが「言葉として良さそうか？」という視点が大切となる。

単に長いから切り出す、から一歩進んで、作り出す抽象としてはどちらが良いか？という視点でコードを切り分けて、時にはコードを追加して切り分けたりしていくようになりたい。


続く。

