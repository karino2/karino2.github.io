---
title: プログラム入門：抽象化の話
layout: page
---

プログラムの入門としての抽象化の話をします。ベテラン向けじゃないんで、ベテランの人は読んでも新しい事は無いと思います。

データ分析界隈だと、数学や物理などで抽象的な事というのには良く出会ってきた経験を持つので、抽象的な物は得意な方だ、という人は多いと思うし、実際そうだと思う。

ただ、プログラムの抽象化は違う部分もあるので、一度プログラムの抽象化という物を初心者の気持ちになって学んでみる機会は必要とも思う。
ここではそんな話をしてみる。

## カプセル化

プログラムの抽象化と言えばカプセル化なのだが、いまいち良い解説が無いので自分で書く事にする。

一般的な事は知らないけれど、プログラムにおいては、抽象化の定義は「情報を落とす」事となっている。
全ての情報を持っている所から、特定の情報だけにする事でアクセスする「口」を定める訳だ。

だからだいたいの抽象化は物を「削る」のだけど、一つだけ例外がある
それが「カプセル化」。カプセル化はプログラムにおいて特に重要な抽象化となる。

### カプセル化の定義

カプセル化とは、「複数の物をまとめて名前を付けて、その名前で一つの物として扱う事」というのが定義となる。
学術的なちゃんとした定義はどっかで調べてください。（ちょっとググったが手頃なのが見つからなかった）。

例えば構造体とかはカプセル化っぽい。以下みたいなの。

```
struct Polar {
    double r;
    double theta;
};
```

rとthetaという二つの浮動小数点変数を一つにまとめて、Polarという名前をつけている。

カプセル化が他の抽象化と違う所として、「新しいエンティティを生み出す」という所がある。
他の抽象化はだいたい削るのが基本なのだが、カプセル化だけは「生み出す」。

ただし抽象化の定義には合致していて、情報は捨てている。
エンティティの名前で呼んでいる時は、そのほかの二つのdoubleで表せる概念、例えば身長と体重の組では無くなっている。
もともとのdouble二つでは極座標でも身長と体重の組でもなんでも扱えるのだが、
Polarにした後はそういうなんでも扱える部分の一部だけに限定されて、極座標だけを扱う事になった。

関数を作るのもカプセル化といえる。

```
double average(double* vals, int len) {
    double sum = 0.0;
    for(int i = 0; i < len; i++) {
        sum += vals[i];
    }
    return sum/len;
}
```

複数の命令、forを回したり足し合わせたり長さで割ったり、といった命令をまとめて、averageという名前をつけている。
使う側はaverageという名前でこの命令全体を実行するのと同じ事が実行出来る。

複数の要素をまとめて一つの名前をつけて、その名前でもって一つのエンティティとして扱う事、これをカプセル化という。

### カプセル化とは概念を生み出す事

複数の物を集めて名前をつける、というのはあまりにも汎用的すぎて、入門のうちはその概念を改めて考えてみるご利益は少ないと思う。
ただプログラムを書くようになったら、どこかのタイミングで考えてみるに値する。

カプセル化、ひるがえってプログラムが特別な所は、概念を生み出す機会の多さにある。
数学でも変数はつけるので、概念を生み出している事もちょくちょくある。
ただ、プログラム的な意味で複雑な概念を生み出す機会は、新しい数学を作る時くらいしか無い。
そういう場はプログラム程は頻繁では無いと思う。

プログラムでは、新しい概念を生み出す事を日常的に行う。
だから数学等で抽象的な物になれていても、この概念を生み出す所の抽象化は少し初心者の気持ちになって学ぶ姿勢が必要な所と思う。

プログラムというのは、究極的には一番下の命令を羅列するだけで目的の挙動をさせる事は出来る。
だからプログラムの初期の段階では、解きたい問題に対して、その解法を記述する命令を羅列する、という活動となる。

プログラムを読む時も、最初のうちは命令列の羅列まで掘り下げていく事が読む事であり、
抽象を壊して全情報に戻す作業が理解する、という事になる。

だが、これは入門時だけの事で、一定以上の現実的なプログラミングにおいては、
それよりも抽象を構築する事の方がメインとなる。
その問題に合わせた「概念を生み出す」というのがプログラムの中心的活動、と言っても過言では無い。

理解をする時も、一番下の命令の羅列までブレークダウンするのでは無く、構築されている抽象を理解するように心がける。

プログラムをする時は、いつもこの概念を生み出す、という事について自覚的になって、
どういう概念を生み出すべきか？という風に考える必要がある。
概念を生み出す時には、いつもカプセル化がその主体となる。
数学とかをたくさん触ってきた人は特に、このカプセル化について改めて考えてみて、
プログラムを見直してみる価値があると思う。

## 抽象化の二面性

概念を生み出すのがプログラムの重要な特徴だが、この生み出した概念、
というのは、「そう考えてやる」事で初めて確固とした実在を得る。
逆にそう考えてやらないと、あまりちゃんとした概念として存在出来ない。

だいたいの抽象化には、二面性がある。
それは使う側と作る側だ。

感覚的には、水面に浮かんでいる葉っぱを地上から見るのと、水面の下から見る、という二つの見方があり、この二つの見方を「意図的に」切り替える必要がある。

先ほどの平均を求める関数を考えよう。

```
double average(double* vals, int len) {
    double sum = 0.0;
    for(int i = 0; i < len; i++) {
        sum += vals[i];
    }
    return sum/len;
}
```

### 使う側から見た抽象化

これは、使う側からは、以下のようなシグニチャで、

```
double average(double* vals, int len)
```

配列の平均を求めるようにふるまう、という風に考える。

実装がどうなっているか、という事は考えずに、提供する機能だけに注目してやる事が大切。
使う側からは「XXという名前でYYという機能を提供している」と、「何をしてくれるか」という視点で考えるのが大切。

中の実装も分かっているのだけど、あえてそこを使う側で考える時は「知らないフリ」をする。
この頭の切り替えがプログラムにおける抽象化の大切なポイント。
実装をあえて「忘れる」事で、提供している「何」に集中する。
この意識を集中させる事で、作った概念がより確固とした物になる。

この、実装をあえて「考えない」で、提供する「何」に着目するのは、出来るようになるべく意識して訓練する必要がある。（そんな難しくも無いけど）

これが水面の葉っぱを地上から見た場合。

### 作る側から見た抽象化

抽象化にはいつも二面性がある。使う側は既に述べた事だが、使う側から見る時は反対に頭を切り替えて、実装に着目する。

着目するのは、実装、つまり以下の所になる。

```
    double sum = 0.0;
    for(int i = 0; i < len; i++) {
        sum += vals[i];
    }
    return sum/len;
```

これこそがaverageという物だ、というのが、実装側から見た視点となる。
葉っぱを水の中から見上げるイメージ。

こちらの視点は初心者でも普通に持っている物なので難しい事は無い。
ただ、初心者はいつもこちらの視点を持ち続けてしまう。
プログラムにおける抽象化においては、こちらの視点は意図した時だけに限って、
その場合はこちらに集中する、というのが重要。

いつもなんとなく実装を思ってはいけない。あくまで「実装側から見るぞ！」と思った時だけ見る。
この見方を頻繁に切り替えて、両方一緒には見ないのが大切。

## 問題領域の言葉で問題を記述する

encapsulationで概念を作り出す事が大切で、その概念をはっきりした物とする為には使う側と作る側を意識してはっきり分けて考える事が大切、という話をした。
これで概念を作り出す事は出来るようになった。

次に、ではその作り出す能力を使って、「どういう概念を作るか？」という事を考えたい。

プログラムの基本としては、まず使う言葉を「問題領域の言葉」まで引き上げて、その問題領域の言葉で問題を記述する、というのがある。
この問題領域の言葉を作るのに「概念を作る」ということを使っていく。

### 問題領域の言葉の例

何が問題領域の言葉か、というのは明確な定義がある訳じゃないが、いくつかの例を挙げることは出来る。
そこからなんとなく感じ取ることは出来ると思うので、例を挙げていこう。

例えば「線形リストのある値のノードまでたどって、その一つ前のnextを新しく作ったノードに差し替えて、新しく作ったノードのnextを先程見つけたノードのnextに差し替える」という表現は、いかにも低レベルな表現だ。
これよりは、「新しくノードを作って、適切な場所に挿入する」の方が抽象度は高い。
さらにこれがスプレッドシートのアプリを作っているなら、「シートのある列の隣に、新しい列を挿入する」の方がよりスプレッドシート、という問題に近い。
この「シートのある列の隣に、新しい列を挿入する」が問題領域の言葉と言える。
「シート」、「列」、こうしたものは問題領域の言葉だ。
なるべくそういう言葉でコードを書く方が良い。

もう一つ例を挙げよう。
「HTTPのリクエストを投げて、結果のxmlのarticleという要素のtitleの一覧を集めて表示し、その表示のtagにはこのarticleのサブツリーをぶら下げておく」よりは、「最新の記事の一覧をリクエストし、記事の一覧のタイトルを表示する。tagには記事をぶら下げておく」の方がより問題領域の言葉に近い。
HTTPとかxmlとかそのelementの名前よりは、最新の記事とか記事の方がより問題領域の言葉に近い。

arrのposに値を代入してpos++するよりは、値をスタックにプッシュする方が問題領域の言葉にちょっと近い（問題に依るが）。
SQLにitemIdをキーにしてtagcloudのフィールドにtagidをもったレコードを追加するよりは、itemに対するタグを追加する、の方が良い。

問題領域とは、解こうとしている問題の言葉なので、解こうとしている問題によって何がより問題領域に近いか、は変わっていく。
ただ以上の例で雰囲気はわかると思う。

### 言葉を作る、という場合の言葉とは？

言葉というのは抽象的な言い方なのだが、これが抽象的な言い方がもっとも適切なので少し説明がわかりにくい部分もある。
例えば新しい問題領域用のプログラム言語を作るなら文法とか語彙が必要になり、いわゆるDSLを作る、という事になる。
一方で問題領域の言葉を作る、と言った場合、普通はDSLに限らずもっと単純なAPIとかも言葉とみなす。
そこで何を言葉とするかは曖昧なのだが、例を挙げてなんとなく空気を感じてもらおう。

もとの問題が大きなAという記述をされているとする。
これから一部を切り出してBという概念を作り、Aのコードを一部Bに切り出す。
で、AはBを使う形でA'という形に変える。

この時にBに対する操作というのが一番原始的な意味での言葉となる。
これだけでは言葉というにはあまりにもしょぼいのだけど、こうして登場キャラクターが増えてきて操作も増えていくと、割と立派な言葉に育っていく。

ただ、単に例えば関数とかクラスでは不十分な場合ももちろんあり、より言葉として複雑である方が望ましくなってくると、何らかの形のDSLを作る事も自然な延長としてありえる。
特に言語内で、ホスト言語と切り離したセマンティクスを与えやすい仕組みのある言語では、比較的一般的でもある。
C#のLinqやkotlinのtype safe builderなどはそうした問題領域の言葉をリッチにしやすい言語機能と言える。


### 言葉をボトムアップで作るかトップダウンで作るか

問題領域の言葉というのは、普通作り始める段階では何が適切かはわかっていない。
それを知る、というのはプログラムというアクティビティの本質的な部分である。
そして何を作るかがわかっていないのだから、それをどう作るかも当然分かっていない。

さて、問題領域の言葉というのは、普通それ自体がほとんど答えに近い。
だから問題領域の言葉を作るのは、直接問題を解くのよりほんの少しマシなくらいしか簡単になってない。
だから問題領域の言葉を作るには、その下のサブ問題領域の言葉を作ることになる。
このサブ問題領域の言葉もだいたいは複雑なので、さらに下にサブサブ領域の言葉を作ることになる。

こうして、言葉はレイヤーになることが多い。

こうしたレイヤーを作っていくとき、普通問題領域のそばと、一番下の実装のそばのレイヤーはなんとなくわかることが多い（往々にして最終的には似ても似つかない物になりがちだが）。
問題領域の言葉は解こうとしている問題の世界で普通に出てくる物が多い。
実装の一つ上のレイヤーは、問題の解法を実装していこうとしたら必要になるutility関数のような物から始まりがちだ。

ということで、最初はこの上から作る向きと下から作る向きの両方を（交互に）考える感じになる。
まず、問題領域の言葉を考える。その言葉を表すインターフェースくらいをぼんやり決める。
ただ実装はまずはハリボテ。なんとなく問題をその言葉で記述する。

次に実装。必要な物を作るのに必要な物を一段くらい考える。その上に何が載るかは良く分からない。
こちらは割と具体的に作れるが、実は必要でない物を作ってしまうのが良くある。
そこで軽く必要そうな物を雑に作って、ハリボテな感じに一応つなげようとしてみる。
もちろん間が無いのできれいにはつながらないのだが、そのところで、上はもうちょっと下にこう降りていかないとだめだな、と気付き、下側のレイヤはもっと上にこういうのを足していかないとだめだな、と分かっていく。

この上と下の両方からちょっとずつ埋めていく。

プログラムの入門ではとりあえず実装をしてそれを整理していく、という形に進みがちだし、それはそれで良い事もあるが、このやり方は小さな問題でしか使えない。
より難しい問題を解くときには、よりしっかりとした抽象概念が必要で、それを作るには練習が要る。

### 言葉である意義

ここまで何度か、問題領域の「言葉」という単語を使っている。
言葉である事は重要なところなので、少し補足したい。

ある問題を解く時に、それをサブ問題にブレークダウンして解いていく、というのは、プログラムの一番最初に学ぶやり方と思う。
これは少しプログラムをやっていれば誰でも出来るようになる。

だが、ブレークダウンしていくだけ、というのは、少し難しい問題になると、あまりうまく機能しない。
最初に頭の中にある問題の解き方に引きずられ過ぎるからだ。

あるコードをメソッドに切り出す時に、その単位は適切か？そのメソッドは誰の責務としてどこに実装されるべきか？そうした問題を考える時に、ブレークダウンしていくだけの思考では抽象概念が弱いコードになる。

そこで「言葉」である事が大切になる。

そのレイヤーの言葉として、何があるべきか？という事を考えるのが、これからどういう抽象概念を生み出していくべきか、の指針となる。

先程の問題AからBを切り出して、A'とBにするケースを考えよう。

続く。




