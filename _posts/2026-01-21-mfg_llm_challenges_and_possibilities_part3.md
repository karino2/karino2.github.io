---
title: LLMの生成先としてのMFGの課題と可能性（その3）
layout: page
---

## LLMに向いた環境を作る大切さとMFGのフィルタという切り口の評価

LLMのコード生成には、向いた分野と向いてない分野があるのは明らかに思う。
これを一段進めると、新しい分野を設計する時には向いているように分野を設計する、
という考えがあるだろう。

今回自分はMFGというプログラム言語を作った。このプログラム言語を作る、というのは、
こうしたLLMに適した分野を設計する際の、重要な選択肢となりうるな、と思った。

MFGはLLMの隆盛よりも前から開発していた言語だし、LLM向けに作ってもいない。
だがたまたまLLMに向いた側面が結構あるな、と気づいたので、そういう話を見ていく事で、
MFGの変わった側面からの紹介と、LLM時代にプログラマが用意するべき環境という事を考えるケーススタディになっているんじゃないかと思って書いてみる。

## 言語で出来る範囲を含めた言語設計

プログラム言語の設計というと、普通はシンタックスとセマンティクスを指す事が多いと思う。
これは暗黙にはアセンブリより先を言語の外側の世界という事にして、
言語設計とはアセンブリまでの事だ、とみなしたいという思いが背後にある。

だが現実的には言語を作る時には、実行時にどのような実行モデルであるか、
つまりランタイムなども含めたものも言語設計の一部であると思う。
特にLLM向けに言語を設計するなら、このランタイムまで含めた、実行時にどうあるかまでが言語設計に含まれると思う。

MFGを例にすると、MFGはシェーダーの言葉で言うなら「シェーダー+ホスト」がランタイムとなる。
ホストが含まれているので、シェーダーにコンパイル出来る訳では無い（一部はシェーダーにコンパイルするが）。
このどこを言語の記述範囲に含めるか、というのはLLM向けの言語を設計する時にはすごく重要な選択となるのを以下いくつか見ていく事になるはず。

MFGはホストを含むのだけれど、ホストで動く制御フローなどは存在しない。
ホストはIRを解析して限定された形でのみ動く。
だからコードを読まなくても、ある限定的な事しかしない事が保証されている。

MFG以外の例で言うなら、CSSとJavaScriptがある。
CSSをLLMで生成させる事を考えるのは、JavaScriptを生成させる事に比べて、影響範囲が予想しやすいだろう。
例え生成されたコードを見なくても、CSSで出来る範囲はJavaScriptよりもずっと少ない。
CSSは見た目だけのくせに高機能なので色々抜け穴もあるかもしれないが、
言語を設計する比喩としてはCSS的なものの方が、生成物を見なくても済む度合いは高いだろう。

これは制御構造が無い方がいいとかdeclarativeな方がいいという話ではなく、
言語の適用範囲が見た目に限定されている、という話だ。

LLM向けに新しい言語を設計する時には、その実行環境まで含めてその言語が何をするのか、逆に何を「しない」のか、
という事は重要なポイントになる。

## 単体で閉じた機能を提供するのが望ましい

MFGは、そのファイル一つでフィルターという独立した機能を提供出来る。
これはLLMでの試行錯誤には望ましい。

複数のファイルをいじるのは対話的に変更していくのがやりにくいし、
一つのファイルに複数の言語が入っているようなものも両者にまたがるような変更は自由度が高すぎてLLMと対話的に自分の望むものに近づけていく作業が難しい。

一つのコード、一つの言語で、一つの単位が提供されている方がLLMとやりとりして開発していくのに向いている。

逆に言えば、複数のファイル、言語にまたがるような特定の作業があって、それをLLMで色々出来るようにしたい、
という場合は、それらのまたがった何かを単一の言語、ソースに統合してみせるようなプログラム言語を開発すると、
LLMのでの生成と相性の良い環境を提供できる可能性がある。

後にも述べるように、コードをどれだけ読まなくて済ませられるのか、というのが、LLMを使うメリットと大きく関連する。
だからコードを読まなくてもその生成したコードは「これをする機能」と言えるようなものになっている方が良い。
「AもBもCも出来る環境でAをするコードをLLMに生成させました」では、本当にBやCをしていないかはコードを読まないと確認できない。
「フィルターを記述する言語環境でフィルタのコードを生成させました」なら、コードを読まなくてもこれがフィルターであるのは明らかだ。
少なくともフィルター以外には害がない事も保証出来る。

## 段階的なコードレビューが可能な方が良い

前回までの記事でも見てきたように、LLMが生成したコードをレビューするのは凄く大変な割に、ご利益は少なく、
LLMに生成させるメリットの多くが失われてしまう。
だから理想的には生成したコードを一才見ずに採用出来るのが望ましい。
どれだけ生成したコードを読まないで済ませられるか、というのが、LLM向けの言語設計がどれだけ優れているか、という事の一つの指標になるんじゃないか。

現実としては、完全に読まないで済ます、というのは、現時点では難しいと思う。
そこで現時点の設計指針としては、全部読むか全く読まないかの間の、
ある程度のチェックは簡単に出来る、というような、「ある程度」を段階的に設計する事なのではないか、と思う。

例えばMFGに関して言えば、DRAMのメモリサイズはテンソルの `@bounds` 属性で指定する事になる。
この値だけをチェックすれば、それ以外のコードを一切読まなくても確保されるDRAMのサイズは確定させられる。

実行のループに関してはrsumやreduceなどの一部のループ系関数の範囲に限定される。
これはネストされうるので、原理的にはかなり複雑で理解の難しいコードも書く事は出来るが、
現実的に使われる多くのケースではネストはせいぜい2段で、範囲を理解するのも容易なものが多い。
この範囲だけを理解すれば、中のコードを読まなくても個々のカーネルの実行コストの大まかな概算は可能となる。
これはwhileとbreakなどのループではより難しくなる。MFGではそうしたループが無いのは意図した設計である。

このように、「コードのここの部分だけを読めばこれは保証出来て、それはコード全体を読むよりはずっと楽」という切り口が用意できれば、
LLMにコード生成させるメリットを残しつつ、どんなコードが中で動いているのか全く把握していないものを使う、
という状態とは違う事は出来るのではないか。

MFGは多くのフィルタでは、「中の挙動は良くわからないがどういうループでどういうテンソルを処理するかは簡単に理解出来る」というコードが多い。
そこまで確認出来れば、表示の詳細の妥当性に関してはわからないにせよそんなに変な事はやってない、という事は確認出来る。

もちろん表示の所でよくわからない暗号的なものを画像に埋め込んだりするリスクはあるけれど、処理するピクセルのパターンが明快な時にそういうのを埋め込むのはかなり難しいので、
完全に何も見ない事に比べればかなり挙動は理解出来ていると言えると思う。

これはLLMを前提とした言語設計という話であれば、言語設計に組み込むべき事になると思う。
MFGで言うならテンソルという概念があってサイズが属性で指定されて、この属性の計算にはさまざまな制約がある事でそこだけを理解する事が出来る、
というような話がそれである。

## 余談： なぜMFGはそのような言語になっているのか？

MFGはLLMによるコード生成の実用化よりも前にデザインした言語なのに、いくつかの側面ではLLM向きになっている。
これは本来は別の目的のためにそう作ったのが、たまたまLLMの文脈では良い性質になっていた、という事だ。
ではその本来の別の目的はどういうものだったのか？というのを最後に軽く触れておきたい。

### ループとDRAMの範囲の自動解析

元々、テンソルに相当するもののサイズを、Halideは自動で計算する。
これは理論的には美しいが、実際に使ってみるとバッファのサイズが意図してないものになっていたりして、自分は最初イメージするほど良いものではない、と結論づけた。
そこでMFGでは自分で明示的に指定している。

だが、サイズの自動的なverifyはやれるならやりたい、という思いもあって、設計上はあるサブセットであれば自動計算は可能になるように作ってある。

ループの実行回数のupper boundも解析できるようにしてある。これも上と同じで、第三者の作ったフィルタをコードのverifyだけである程度安全である事を保証したい、
と思ってのことだ。
ただこのverifyは実装していない。
途中まで実装してあったのだが、最初のリリースでは最低限の機能を持ったものを高品質に提供すべきだ、と思ってこの辺は削った。

これは言語機能どうこうという話とは別に、フィルタの
