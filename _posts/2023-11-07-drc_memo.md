---
title: Differential Reference Countingのメモ
layout: page
---
[【書籍】CppConcurrencyInAction](https://karino2.github.io/RandomThoughts/【書籍】CppConcurrencyInAction)を読んでて全然わからんな、と思っていたDifferential Reference Countingだが、
[1024coresに解説を発見](https://www.1024cores.net/home/lock-free-algorithms/object-life-time-management/differential-reference-counting)。
ただなかなか難しいので、ここにメモを取りつつ考える。
なお、本ポストではDRCと略す。

## なぜ単なるリファレンスカウントに出来ないのか？

DRCの解説で良くわからない事としては、一体何をしようとしているのか、という所に思う。
そもそもになんでリファレンスカウントをatomicなカウンターに持つだけではうまくいかないのか？という事をはっきりさせたい。

### 問題設定

やりたい事は、まず何らかのリファレンス、rのようなものを作りたい。
これはオブジェクトへの参照で、並列に「違うオブジェクトがアサイン」されたりする。
そしてこのリファレンスに格納されるオブジェクトをリファレンスカウントで寿命管理したい。
これがやりたい事に思う。

寿命管理は、

```
auto obj = r.acquire();

objについての操作

obj.release();
```

のような感じでやりたい。rから参照されている間はobjは当然活かし、またacquireで誰かが保持している間も活かす。
releaseはrに入っているオブジェクトが変わる場合も考えればobjにしたいだろう。

### objにアトミックなリファレンスカウントをもたせるだけでは何故うまくいかないのか？

rにobjへのポインタを持たせて、objにリファレンスカウントをもたせる、というのが一番普通に考えた時に出てくるアイデアだろう。
だがこれは、

- objというポインタをたどる事
- objのリファレンスカウントをインクリメントする

の２つをアトミックに出来ない、という問題がある。
例えば以下のようになっているとしよう。

```
struct Object {
  std::atomic<int> count;
  // そのほかデータ
};

struct Ref {
  Object* obj;

  Object* acquire() {
    auto o = obj;
    // この間でobjを削除されるかもしれない
    o->count++;
    return o;
  }
};
```

このacquireは、objからポインタを取り出した後にオーナーシップを宣言しようとするのでまずい。
だが、カウンタを上げつつobjの参照を取る、という事をatomicにやる方法が無い。

ABA問題とか削除されるとかの問題を無視すれば、やりたいatomicオペレーションを無理やり言葉にするなら、
「objがoと等しい時にo->countをインクリメントする」
となる気がする。

objをatomicにしてcountをatomicにしても、コンペアするatomic（objの事）と++するatomicが別になるので、
これは並列プリミティブとしてはうまく行かない。
単なる位置のdouble wordのCASよりもさらに複雑だろう。

### rにアトミックなカウンタを持つだけでは何故うまくいかないか？

objを参照する前にリファレンスカウントを上げるなら、rにカウンタをもたせれば良さそうな気はする。
rのカウンタを上げるのとobjをderefするのをアトミックにする必要はあるけれど、
objのポインタとリファレンスカウントは同じ場所にあるので、先程のobjとobjの中のcountのような全然別の場所とは違うから、だいぶどうにかなりそう。
そこはだいたいのDRCで解説がある所で分からない所でも無いのでいいだろう。

だが、これも少し考えるとダメな事が分かる。
それは、rがacquireされている間に別のobj2をassignされると、
obj1のリファレンスカウントがクリアされるしか無いからだ。

obj1とobj2が順番に入れられると、以下のようになる。これはまずそう。

1. obj1をrに入れる。rのカウンタが1になる。
2. obj2をrに入れる。obj1のカウンタが失われてしまう。

少し考えれば、2の時にobj1のカウンタに移動すれば良さそう、という事でDRCのアイデアに到達する事になる。

## DRCによる解決策

この２つを混ぜた解決策がDRCとなる。
まずrにリファレンスカウントをもたせる。そしてobjにもリファレンスカウントを２つもたせる。
一つはリファレンスされている個数、もうひとつはobj自身のリファレンスカウント。

つまり、全部でリファレンスカウントは３つになる。

1. rのリファレンスカウント
2. objの、rから参照されている数を表すリファレンスカウント（orefカウントと呼ぶ事にする）
3. obj自身のリファレンスカウント（basicリファレンスカウント、obrefカウントと呼ぶ事にする）

2と3を工夫して一つにする事も出来るけれど、そういう事を最初にやると意味がわからなくなるので、
まずはこの３つで考えるのが良いと思う（1024coresもこの３つで考えている）。

rからobjを取り出して作業する時は、

1. rのリファレンスカウントを++する
2. objで作業する
3. objのbasicリファレンスカウントを--する

rのリファレンスカウントとobrefのリファレンスカウントが別の場所にある、
というのがポイントその1。
1と3が同じだと作業している人がいない、という事を表す。

また、rがリファレンスしている間はいつもobjは削除されないために、
参照がなくなるまでは削除の事は考えなくて良い。

### 削除の条件

削除の条件は

1. 作業中の人が居ない
2. objを参照しているrが無い

の２つになる。
obj2がアサインされる事を考えなければ、
rのカウントとobjのobrefが足すと0になり、
さらにrからの参照がなくなる時（objのorefが0になる時）が削除条件になる。

だが、obj2がrにアサインされるケースも合わせて考える方がシンプルになる。
obj2がrにアサインされると、

1. objのorefを--
2. objのobrefにrのリファレンスカウントを移動（足す）

となる。

これを行った後では、削除条件は「obrefが0かつorefが0」になる。

削除されうる場所は、

- objのrelease
- rへの（別のオブジェクトの）assign

の２つの場所になる。

### 参照の種類をまとめる

参照は２つの場所からの参照がある。

1. rからobjへの参照
2. rにacquireをした人の持つ参照

### もう一度大雑把なアイデアをまとめる

同じような話を何度もする事になるが、自分の理解のためのメモなので仕方なし。

大雑把なアイデアとしては、

- rにaddRefするカウントをrにもたせて
- objにreleaseするカウントはobjに持たせる
- けれどrから参照を外す時にこのrのカウントをobjに移動させる。

という事だな。こうする事でrにobj2が入れられた時に、
ｒのリファレンスカウントをobjに移す事が出来て、
以後はobjのリファレンスカウントだけで寿命が管理出来る。

rからリファレンスされている間は死ぬ事は無いので考えなくて良い。

r1とr2からobjが参照された場合とかもうちょっと真面目に考える事はあるけれど、
基本的にはこれ。

キューのheadとか複数の場所から参照されるオブジェクトのホルダのようなものが実現出来て、
しかもリファレンスカウントで管理出来る。

よし、だいたい理解出来た！