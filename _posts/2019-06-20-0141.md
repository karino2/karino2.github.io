---
title: kotlinで簡単なテンソル処理がしたい
date: 2019-06-20 11:53:12
---

やりたいのはストロークのノーマライズとか。そういうのを簡単に書きたいが、そのためにAny型をいろいろdynamicに処理するのは嫌だ。型のための多少の冗長性は受け入れよう。

ストロークはshape的には(strokenum, one_stroke_len, 3)で、最後の3はx, y, 0か1のトリプレット。
最後の0か1は、座標がある所は1、無い所は0。

で、ノーマライズはトリプレットの最後が1の所だけのxの最小値をxから引く、とかそういうのが書きたい。

numpy的には、あってるかわからんが、こんな感じ。

```
mask = strok[:, :, 2] == 1
xmax = stroke[mask][0].max()
```

こういう感じの処理を書きたい。
maskのshapeは(strokenum, one_stroke_len)で、boolだった。

`stroke[mask]`のshapeは(trueの数, 3)となる。

と思ったが、モデルの都合でこのノーマライズは要らない事に気づいた。だいたい定数倍でいいか。
だから

```
stroke[:, :, 0]*k
stroke[:, :, 1]*k
```

あたりが出来れば良いか。inplaceの方が本当は良いんだろうが、代入出来ればまぁ最初はいいかなぁ。

ようするに、インデックスのシーケンスが得られればいいんだよな。
何かしらのtype safe builderがあって、

```
{all; all; n(0)}
```

とかでインデックスの列が返ってくるとかならどうだろう？
ある範囲ならrangeでrとか？

```
{all; all; r(0, 10)}
```

とか。rはもうちょっと考えた方が良さそうだが。

こんな感じのDSLが定義出来れば、部分配列を取り出すのをsと呼べば、

```
stroke.s{all; all; r(0, 10)} * k 
```

とかで

```
stroke[:, :, 0:10]*k
```

的な事が出来るとか？
代入は変なトリック使うよりは、assignerみたいなのを返すとして、それがaとすると

```
stroke.a{all; all; r(0, 10)}(stroke.s{all; all; r(0, 10)}*k)
```

読みにくいが書きやすさは悪くも無いか。