---
title: "GoodfellowのDeepLearning本を読む"
date: 2018-05-22 01:44:27
---

プログラム言語の本もだいたい読んだので、次は機械学習の本でも読むかな、と思い、Goodfellow本を読む事にする。

<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=qf_sp_asin_til&t=karino203-22&m=amazon&o=9&p=8&l=as1&IS1=1&detail=1&asins=0262035618&bc1=ffffff&lt1=_top&fc1=333333&lc1=0066c0&bg1=ffffff&f=ifr"> </iframe>

ちょうど年末に買っておいたので。

### どう読むか

この本は多分Deep Learningをバリバリやってる人向けでは無く、これからやっていきたいという人向けにいろいろ紹介していく、という物と自分は思ってる。
Deep Learningという物を良く知らない人が基礎から理解していき、最新の研究の入り口くらいまでの話題をいろいろ知る、という本なんじゃないか。
（まだ読んでないので予想だけど）

一方で自分は画像認識に関してはプロフェッショナルといえる水準だと思う。
実サービスで使っていく難しさとか自分たちなりの解決など、十分な経験がある。
だからこの本が目的としている、「読者をここまで連れていきたい」という場所よりは、既に先に居るんじゃないか。

この本が出たあとの論文もいろいろ読んでいるし、モデルもいろいろ触っている。だから自分にとっては、いろいろなトピックや研究を知る、という目的でこの本を読むのは、いまさらな感じがする。
変化が早い分野だからねぇ…。

目次を読む限り、トビックとしてはPart 3の知らない所だけ読めば事足りそうだが、それではたぶんあんまり読む事は無い。それが一番効率的な読み方かもしれないけど、どうせ暇なので、もうちょっと違う所を読んでみたいな。

ということで、せっかくGoogfellow御大が本を書いてくれたのだから、彼がニューラルネットをどう捉えているのか、みたいな、著者個人の感性みたいなのに注目して読んで行こうかなぁ、と思う。うまく行くかは分からんが。

逆に読者がDeep Learningを学ぶ為に必要、という感じの記述はガンガン飛ばして行きたい。
例えば今更Drop outとかBatch normarizationなどの話は読まなくて良かろう。

# Introduction

自分の目的を思うと、このintroductionとかのポエムパートの方がむしろ重要かもしれない。

MLPがrepresentation learningのような物だ、というのはいいとして、
マルチステップのプログラムを学習しているような物と見れる、というのは面白い。
確かに中間レイヤのWが何に使われているのか、というのは、多様な見方を身に着けておく方が良い気はする。

### 想定読者

どちらも自分は入って無さそう。
その辺はそんな気はしてたので、自分に必要なように読んでいきたい。

### history

brainの模倣の路線では無くなった理由、とかは興味深いな。

wax and wane 盛衰。月の満ち欠け。waxに月が満ちるって意味があるのね。

### Introduction読み終わり

これが書かれた時とその後のトレンドは結構違うな、と思う。

ネットワークは最近はむしろ小さくなっているし、タスクが汎用になっているよりはより難しいタスクに挑む傾向がある気がする。

ある時点で振り返った時に続いている傾向がその後も続く訳では無い、というのは、重要な洞察だよな。

ただある一時点で過去からの流れをこうしてまとめて見る事は、そういった一歩引いた視点で物を考えるのには有用な気がする。

なかなか良く書けてて面白い導入だった。

# Part 1 Applied MathとMLの基礎

ここはタイトルからすると飛ばし読みでいいかなぁ、という気がするが、軽く見てから考えよう。

## 2章、線形代数

あつかってるトピックを眺めていく

- 行列、テンソルの定義
- 行列積、Identity、Inverse
-  Linear dependenceとspan

spanとはなんぞや？という事で2.4は軽く見てみる。
基底とか線形結合の話か。
この辺は日本語で勉強したので英単語知らないから、単語の勉強として軽く読む。
linear dependenceは線形従属の事やね。

そのあと特異値分解とかpinvが雑に紹介されてる。この辺をラプラス展開からちゃんとやらないのは気に食わないが、そういう本だという事だ。

reciprocalは逆数。良く出てくるがすぐ忘れる単語。

Frobeeius norm がトレースで表せる、という式2.49、見た覚えあるが、成り立ってるか軽く試す。

![](https://i.imgur.com/x3pDBXr.png)

成り立ちそうやね。

### 2章読み終わり

線形代数の提示の仕方としてはあまり好きになれない内容だが、線形代数の本じゃないのでこの辺はどうでも良い。

## 3章 確率論と情報理論

確率論は割と本気でやった領域なのでこの本で何か知る事があるとも思えない、という事で軽く流す。

最初に確率論ちゃんと勉強するならJaynes 2003を読め、と書いてある。

これか。

<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=qf_sp_asin_til&t=karino203-22&m=amazon&o=9&p=8&l=as1&IS1=1&detail=1&asins=0521592712&bc1=ffffff&lt1=_top&fc1=333333&lc1=0066c0&bg1=ffffff&f=ifr"> </iframe>

amazon.com側ではレビューがいっぱいついてて、ベイズ統計の教科書っぽい。
jpでは一件もレビューがついてないのは、きっとみんなGoodfellowが提示してるリファレンスなんて見ても居ないからに違いない。

目次が読みたかったのでKindleにサンプル送ろうとしたら、おまえの国には送らん、と言われる。ぐぬぬ。

[本家のサイト](http://www.cambridge.org/gb/academic/subjects/physics/theoretical-physics-and-mathematical-physics/probability-theory-logic-science?format=HB&isbn=9780521592710#VQP13Vzbv7tYKUI5.97)はGoogle previewというので目次が見えるな。

ベイズ統計メインでタイトルのように論理的な推論の拡張として考える話があるが、それ以外のトピックもかなり多様に見える。

decision theoryとか結構長い。
毎回ちらっといろんな本に出てくるが何を言いたいのか良く分かってないので一度やってみても良いかもしらんが、まぁ今はいい。

数学的には初等的な範囲に見える。
あくまでベイジアンな応用をちゃんと扱う、という感じで、解析的な扱いはあまりして無さそう。

なかなか本格的な本ではあるが、さすがに生成モデル全盛の今の時代にこのレベルでは辛いのではなかろうか。

### 確率変数のあたり

3.1でfrequentistとbeyesian論争的なポエムがしばらく書かれたあとに、3.2で確率変数が出てくる。

「A random variable is a variable that can take on different values randomly.」
 
えっ？まじ！？

ってこの説明ではさすがにディープラーニングの話は出来なく無いか？
でも一パラグラフで確率変数の話を終えて次の3.3に進んでしまっている。

Goodfellow先生は確率論の解析的な話とかは全然重視てしないのかなぁ、数学なんか詳しくなくてもepoc makingな論文は書ける！という事なのだろうか。
さすがGoodfellow先生ほどの実績を残す男は違うな…  
ふむむ、考えさせられる。

と思い先を読むと、3.3.1でProbability Mass Functionという名前で結構突っ込んだ分布の確率測度の話が、そうした学術用語を出さずに続く。

えー、そりゃ無いよ！Goodfellow先生！

これはこんな書き方では測度論知らない人は何を言ってるのかすら理解出来ないだろう…

random variabieのstateとか完全に未定義な単語でいろいろ語るが、どう見てもボレル集合族の元の話だし、PMFが可測関数だって話だよなぁ、これ。

うぉ、そのあとに確率測度の満たす性質でもっとあらわに書き始めた！酷い開き直り！

うーん、ここまで開き直るくらいなら、最初からボレル集合族という言葉を出す方がずっと誠実だと思うんだが…

追記: 3.12に測度論の話あり。そちらに3.3の感想を追加。

### 初歩的な確率の関係

3.4から3.7まででマージナライズや積の法則や条件つき確率などの基本的な話を短くしてある。

この辺は確率論を忘れてる人が思い出す為、という感じで、初めて学ぶ人が読む物では無いし、この辺普段から使ってる人が読む物でも無い。

### 3.8 期待値とかcovとか

期待値はGANとかではかなり込み入った話となるので、注意して読もう、と思ったが、これがまた短い。
ただ普通の入門書の期待値よりは記法の話が細かい。これは必要だからだよな。

covの定義などの書き方も、統計の入門書よりは、より論文的になっている。

そのあと独立とcovがゼロの関係とかの話がダラダラとされている。この辺の突然素人向けの注意が挟まれるのはDeep Learningという言葉に寄ってくる人の性質を表しているなぁ。

### 3.9 良く出てくる分布

ベルヌーイ分布やガウス分布はおなじみだが、ポワソン分布やガンマ分布が出てこないのがディープラーニングやね。

やはりガウス分布の扱いは長い。

そして指数分布やらプラス分布、ディラック分布などはなかなからしさがある。
emprical distributionも機械学習らしさがあるね。

混合分布も意外と真面目に扱ってる。Gaussian mixtureとかやるの？
16.5で構造推定みたいなのやるらしい。
なんかPGMっぽいなぁ。

### 3.10 sigoidとsoft plusの性質

soft plusってあんまり知らないのでこの機会に覚えておく。
ついでにシグモイド関数の微分とかの式を眺めておく。

### 3.12には測度論の話がある

3.12まで読むと、先程まじかよ、って思った3.3.2は真面目にやると測度論が要る、という話をする。

だが3.3.2のどの辺が測度論が分かってないと良く分からないのか、という話はせず、機械学習の対象では病的な奴は出てこない、という話がある。
また、むしろ証明などを記述する道具として便利だ、と述べている。
この見解は自分と同じなので納得は出来る所。

でも3.3.2の話を測度論がわかる人向けにしないっていうのはどうなんだろう？これでは測度論を知らない読者が、その必要性を知る事は出来ない。

### 確率論の話を読んでの雑感

自分は実解析を最近かなり真面目にやってたのでその周辺の話を。

この本は、測度論の話を出す時に、測度論の用語を使わずに書く。
その結果、おそらく測度論を知らない人は、たまに良く分からない記述が混ざるが、別段分からない事は無い、と感じるんじゃないか。

でもこのたまに良く分からない所が混ざる、という所が後ろの方ではたぶん分からない元になるはずと思う。

少なくとも自分はかつて、後ろの方のトピックの元論文を読んだ時に良く分からないからどんどん遡っていった結果実解析をやり、その結果これまで分からなかった事がいろいろ分かるようになった。
だからまだの人はきっと私とは逆向きに同じ過程をたどるんじゃないか、と思う。

ただ、この本ではその分からない理由が意図的にわかりにくく書かれているように見える。
それは何故だろうか？

まず一番ポジティブな解釈としては、本当にこの辺の事を知らない人でも、だいたいは理解出来るように書ける、と思って書いた可能性。
私は3章の終わり時点までで既にそれは失敗していると思うが、
本当にそれを目指して書いているなら、応援したい気持ちはある。
たぶん誰かがそれをやれば大分関連分野の数学的敷居は大きく下がる、と自分も長らく思っていた所なので。

一番ネガティブな解釈は、どうせDeep Learningとかいって騒いでる連中のほとんどは内容が理解出来る訳では無いので、そういう連中は間違って買ってしまえばよろしい、と思ってそういう本に仕立てた、という事。
さすがにこれは無いか。

現実的には、これで分かると思って書いているが全然分かんねーよ、ってあたりな可能性はある。
Goodfellowが確率の根本原理に詳しすぎる結果、3.3の書き方で自然とボレル集合族的な物が感覚的に分かってしまうので、皆も分かるだろう、と思ってるとか。
これはありそうだなぁ…

さて、著者の意図はおいといて、読者の我々はどう向き合うべきか、という事を考えよう。

ここまで読んだ限り、必要な事に関しては、分かっている人が読めば分かるが、分からない人が読むと良く分からないように、という形で、一通り書いてあるように見える。

だから自分が分かっている分野に関しては、「これとこれとこれを分かってればいいのね、おっけー」と思って読めば良さそう。

問題は自分の良く知らない分野だ。
自分の良く知らない分野で、何を言ってるのか良く分からないが、なんかどうでも良さそうな事を言ってるのを見つけた時。

これはたぶん分かる人向けのメッセージなので、たぶん分かる方が良い。
特にあとの方で関連しそうな所でさっぱり分からなくなった時は、ここに立ち戻って、その関連分野を真面目に学ぶ必要があるのだろう。

だから、どうでも良さそうだが何を言ってるか分からない物を見つけたら要注意だ。ブックマークなりこのブログにメモなり残して、あとで分からない所が出てきた時にそこ由来かチェックしよう。

後半の内容読んでみないとここまでの印象があってるかは分からんので、読み進めてまた感想書く。

### 3.13 Information Theory

この節は以前職場にこの本が置いてあって、立ち読みした事がある。

自分はこの分野はやった事無い。
ガラケー屋だった時にCDMAなどでこの辺の話をちょっとやったのと、あとはKLダイバージェンスやエントロピーを使ってる、くらい。

PRMLでもこの本でも情報理論に言及があるので、真面目にやった方が良いのかもしれない。

最初に紹介されている本はCover and Thomas (2006)とMacKay (2003)らしい。

Cover Thomas 2006はこれで、

<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=qf_sp_asin_til&t=karino203-22&m=amazon&o=9&p=8&l=as1&IS1=1&detail=1&asins=0471241954&bc1=ffffff&lt1=_top&fc1=333333&lc1=0066c0&bg1=ffffff&f=ifr"> </iframe>

MacKey 2003はこれか。

<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=qf_sp_asin_til&t=karino203-22&m=amazon&o=9&p=8&l=as1&IS1=1&detail=1&asins=0521642981&bc1=ffffff&lt1=_top&fc1=333333&lc1=0066c0&bg1=ffffff&f=ifr"> </iframe>

MacKeyの方が自分には合ってそうだが、本家のサイトにも電子版が無い…  
うーん、スキャンするのかったるいなぁ。どうしたもんか。

さて、内容に移る。
エントロピーがその分布をエンコードする下限のビット数の期待値となる、というのは自分は理解してない所で、
どうでも良く見えるがこれは知ってる人向けのメッセージなのだろうな。

KLダイバージェンスの追加に必要なうんたら、というくだりも良く分かってない。

KLダイバージェンスと非対称性の図3.6は、まったく同じものをPRMLで見た気がする。

良く忘れるのでKLダイバージェンスの式は書いておくか。p72。

![](https://i.imgur.com/sdTkGHm.jpg)

クロスエントロピーとかの話はPRMLのEM法で結構やったので理解出来てると思う。

### 3.14 Structured Probabilistic Models

この辺は超得意分野だぜ〜

- [PGMコースの受講メモ](http://jbbs.shitaraba.net/bbs/read.cgi/study/12706/1466006216/)
- [PRML勉強会、36〜60](Pattern Recognition and Machine Learning
http://jbbs.shitaraba.net/bbs/read.cgi/study/12706/1481675604/36-60)

以前junction treeアルゴリズムとかをちゃんと理解する為に、以下の本と、

<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=qf_sp_asin_til&t=karino203-22&m=amazon&o=9&p=8&l=as1&IS1=1&detail=1&asins=4320111397&bc1=ffffff&lt1=_top&fc1=333333&lc1=0066c0&bg1=ffffff&f=ifr"> </iframe>

あとDaphneの本も買って、面白そうな所だけつまみ読みした。

<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=qf_sp_asin_til&t=karino203-22&m=amazon&o=9&p=8&l=as1&IS1=1&detail=1&asins=0262013193&bc1=ffffff&lt1=_top&fc1=333333&lc1=0066c0&bg1=ffffff&f=ifr"> </iframe>

内容としてもベイジアンネットとマルコフネットの話で何も分からん事は無い、という感じ。
Part3で突っ込んだ話をする、との事で楽しみだ。

# 4章、数値計算

ペラペラめくった所、grad descentとかキューンタッカーの定理とかの話っぽい。
飛ばすか悩むが、軽く読んでおくか。

### 4.3.1 JacobianとHessian行列

4.3のgrad descentの説明まではさらさらと読んで行った。で、4.3.1のHessian。

HessianはPRMLで出てきた時に、結局何に使うのか解説されてなくて良くわからんなー、と思ってた所なので真面目に読んで見る。

Hessianが対称とかgradのヤコビアンだ、というあたりまではいい。

そのあと、単位ベクトルdによるsecond derivativeが $$d^TH\ d$$で表せる、みたいな話は知らない話だな。

軽く手を動かしておこう。
まず1階の微分から。p82に載ってるが、この手のは久しぶりにやる時は添字をサボらないに尽きる。

簡単の為、R2からRへの射影の場合をやろう。

![](https://i.imgur.com/mZW5olY.jpg)

よし、だいたい思い出した。
では二階の微分をやってみよう。

![](https://i.imgur.com/bevYxhn.jpg)

![](https://i.imgur.com/GkorLu1.jpg)

![](https://i.imgur.com/YXzmnvW.jpg)

そのあとdがヘッシアンの固有ベクトルなら二階の微分が固有値になる、というのは、簡単に出せるな。

![](https://i.imgur.com/F8fwr7t.jpg)

固有ベクトルじゃない時は、固有値の重み付け和になる、という話だが、これは対象とする方向ベクトルを固有ベクトルの線形結合で書けばそうなるだろう。

で、この方向ベクトルを変えていって二階の微分最大の場所は固有値最大の固有ベクトルの方向になる。
これもほぼ明らかだね。

さて、これを使ってのstep sizeの決定。
4.10は4.9をイプシロンについて平方完成すれば出そう。

そしてgradを先程の固有ベクトルの線形結合で表す議論を思い出せば、ラムダmaxの逆数になるのも明らか。

次にこのHessianの使い方として、ヘッシアンの固有値が大きく違う方向があると、片方で適切なラーニングレートではもう片方にとって適切でなく、いったりきたりを繰り返して無駄に進むケースの図がある。

そして二次の項まで考えたニュートン法の式がある。

この辺の話は使うのかね？ 
そのあとに鞍点ではgrad descentに劣る、とか書いてあるな。やっぱり使わなくない？

### リプシッツ定数の説明が！

そのあとに唐突にリプシッツ連続とリプシッツ定数の説明が。
この辺に触れてるのはDeep Learningっぽいね！後半どう使うのか期待！

そのあとにはconvexなケースの話があるが、Deep Learningには関係ないような。
そう書いてあるな。なんで触れたんだろ？

### 4.4 制約下での最適化

これはキューンタッカーとかの話っぽいね。
経済学好きでは見慣れた分野なので知らん事も無い気はするが。

slackかどうかをこの本ではactiveかどうか、と呼ぶらしいね。言葉は覚えておこう。

### 4章雑感

これ本当にDeep Learningで使うの？というのが混ざってる気がする。
ニュートン法とか。
本当にその発展の議論があるなら興味深いので楽しみに読んでいきたいが、なんとなく載せただけなら幻滅だなぁ。

soft maxの話とかリプシッツ連続の話が出てくるのはDeep Learnigって感じするね。

Information theoryはそのうちちゃんと勉強します、はい…

# 5章 Machine Learning

目次を見る限り、さすがにこの章は飛ばしてもいいかなぁ、という気もする。

一応各節、見るだけは見てみて、分かってそうな所はバンバン飛ばそう。

### 強化学習もやらんとなぁ

強化学習はこの本のスコープ外だ、との事で、挙げられてる本がちょっと古い。

Sutton and Barato 1998はこれか。

<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=qf_sp_asin_til&t=karino203-22&m=amazon&o=9&p=8&l=as1&IS1=1&detail=1&asins=0262193981&bc1=ffffff&lt1=_top&fc1=333333&lc1=0066c0&bg1=ffffff&f=ifr"> </iframe>

お、comの方はなかなか最近のレビューが多くて好評価な上に、Kindle版があるな。

Bertsekas and Tsitsiklis 1996はこれか。

<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=qf_sp_asin_til&t=karino203-22&m=amazon&o=9&p=8&l=as1&IS1=1&detail=1&asins=1886529108&bc1=ffffff&lt1=_top&fc1=333333&lc1=0066c0&bg1=ffffff&f=ifr"> </iframe>

タイトルは全然それっぽくないがcomのレビューを見るとそれっぽいな。ただこちらはレビューの数がぐっと少ない。

DPとの関係とかはちょっと興味がそそられるが、Kindleが無いから読むなら前者か。

次はSuttonのこの本読むかな。
そろそろ強化学習やるか、という気がしてたし。

### 5.2のModel Capacity

あまり知らない言葉として、representational capacityというのが出てきた。
そのあとVC dimensionというのが出てきてるが、これも良く知らない。

AICとかBICの情報基準はPRMLでやって、割と真面目に導出も勉強会でやったが。

あんまり手頃な参考文献も載ってないのと、p111の下の方にあるようにDeep Learningではこの辺の議論は難しそうな印象がある。
結局モデルのcapcity全体を探索してるのとは程遠いのが昨今の現実なので、そっちを議論してもなぁ、という。
実際パラメータの数とかモデルのメモリ的なサイズとか、そういうもっと雑な指標で比較してるよねぇ。そっちの方が便利だったりもするし…

### 5.2.1 no free lunch theorem

なんかこれ、前に菊田さんがこの定理の証明の話して、プリントアウトした物が部屋に転がってるなぁ。
全然読んでないが、この機会に読んでみようかしら？

## NFLの別証明

[No Free Lunch Theoremの別証明と解釈](https://ci.nii.ac.jp/naid/110002812562/)

菊田さんが言ってたのはこれかな。こっちの方が元論文より良いと言ってたのでこっち読むか。

### 2. 定義

2.2の定義で、$$F(d_k)$$が難しいな。
$$d_k$$はxとyの両方の履歴で、Fは評価関数であって、次のxを生成するアルゴリズムは含まないのに注目するとなんだか分かるか。

ようするにその履歴の全$$x_i, y_i$$の組に対して、このマッピングを行う評価関数の集合だな。

で、次の式4はどういう事だろう。

![](https://i.imgur.com/pEMxjYL.jpg)

そのあとに説明があるな。k個のマッピングは既に決まっていて、残り「X全体-k」個のxからYへのマッピングが残るからこうなるのか。なるほど。

そしてaとyの系列を与えると、それに矛盾しないようにfを決められる、という話がある。

aは結局xしか決めないので、
いつもその決められたxに対して後出しで目的のyを用意していく事が出来る訳だ。
これが関数になっている為にはxが同じ所を通っては行けないが、それは前提になっている。

この時点で感覚的には、もうaをどう工夫しようと、全ての評価関数で良い物は存在しない、と言えてしまう気がする。

さて、3章の証明まで行ったら文字が多くなって何が何を表してたのか分からなくなったので、真面目にメモする。

まずaとfが与えられると探索履歴が生成出来る。これを$$S_k(a, f)$$と書く。つまりSは探索履歴。

次に、$$a, d^y_k$$を与えた時に、それに矛盾しないようにfを決めて、その上で作られる探索履歴を$$R_k(a, d^y_k)$$と書く。

### 3. 証明

式9を考えよう。φってのが何か、というのはそんな重要じゃなくて、ようするに右辺のシグマの下の式が左辺のシグマの下の式と同じ物を表している、というのが重要っぽい。

右辺はyの系列ごとにまずfor文を回し、その中で各yの系列に対し、それを実現するfの集合について和を取る。

これはaによらず、全体を漏れなく重複なく舐めるらしい。ふむ。

証明も背理法でそんな難しくないな。

この補題を用いたNFLの証明は、なんか式見るだけだと良く意味が分からないのでサボる。

### 4. 考察

4.1で言ってる事が証明を逆から見てるような形になってて分かりやすい。

ある評価値の履歴があると、どのようなaに対しても、必ず同じ数だけのfがある、というのが証明の内容のようだ。
それは分割の補題と2.2の内容から、感覚的には自然。

ようするに組み合わせの個数（濃度）で議論出来るので、全通りを考えると組み合わせの数は同じっていうのは、感覚的には分かりやすい。

また、この含意から万能分類器を作ろうと努力するのは無意味、というのも分かりやすいな。

なんか理解しやすくてお得な定理だ。

---

さて、本に戻ろう

### 5.4.5 Consistency 

何気なく確率収束が出てる。
こういう、含意を説明せずにいろいろ持ち出すのはこの本の特徴だよな。

分かって無い人には分かって無くてもいい、と思わせるように書かれている。
自分にはそれは誤った幻想に思えるが、実際私とGoodfellowのどちらが正しいかは良く分からない所。
分かってない状態で読んだ人たちが決める事なのだろうな。

### いろいろ読み飛ばす

5.5 最尤推定。この辺の話はさすがに散々PRMLでやったのでいいかなぁ、という印象。

SVMとかdecsion treeもいいだろう。
というかこの辺要るのか？

5.8のUnsupervised learningもembeding的なつながりを意識して書いているかな？と軽く眺めたがそういう空気が感じ取れなかったので読み飛ばす。 
ただ最後のsarseなrepresetationとdistributedなrepresentationの話は真面目に読んでおく。

5.9のstochastic grad descentは文章が長かったので読んでみたが、別段特筆することはない。

5.10の抽象的に書くとMachine Learningのアルゴリズムは一般的に書けるよ、というのも別段新しい事は無し。

### 5.11 DLが欲しくなるような課題

MLの最後に、既存のMLではうまく解けないような課題についてのまとめがある。
ここは真面目に読もう。

curse of dimensionalityに対して、既存の学習手法が織り込むpriorでは不十分で、DLはfactorのcompositionから生成されてる、というpriorを想定する、というのはなかなか興味深い（5.11.2、p155の下部）。

No free lunch theoremを見ると、全てのコスト関数を対等に扱ってはいけない、というのが鍵な訳だよな。

我々は自然界とかに良くあるような画像に興味があるのであって、ランダムのピクセルパターンには興味が無い。
そこで我らが興味ある形を、どうタスクに十分な程度にspecificにしつつ、いろいろな事に使いまわせる程度に一般的に保つのか、というのが我らの目指す事な訳か。

前、Decision treeでrecommend作ってた時に、次元が多いと意外と重要と思ってるフィーチャーの組み合わせに当たってくれない、という事があって、割とcurse of dimentionalityだよなぁ、とか思った事があった。

この時DL的には、ありえそうなフィーチャーのありえそうな組み合わせの関数形は過程しつつ、その組み合わせなどは学習していけるようにネットワークをデザインする、というのがやりたい事なのだろうなぁ。
これに階層性を追加する事でかなり汎用的な物が扱える、というのはありそうな気がする。
次やる機会があったらやってみたいな。

一方でKaggleとかでDT系の方がスコアはいいのだから、なかなか当たらないのを手でフィーチャーエンジニアリングする方が現時点ではいいんだろうなぁ。

### 5.11.3 manifold learning

多様体分かんないお(´・ω・｀)

確率論のあたりの記述を見れば分かるように、こういう自分の知らない分野の記述はきっと学ばなくて良いかのように誤解するように書かれているのだろうなぁ。

やっぱりそろそろ多様体は勉強すべきなのだろうね。

このmanifold hypothesesとかの話はいいな。
word2vecとかから我々はそういう事は考えていて、transfer  learningとかボトルネックをembeddingとして使うのはもちろんそういう考えがあってやっていた訳だが、
それはNFLから考えても王道であり、GANなどもランダムのパターンとは違う、という事を学習させようとする試みと考えられて、いろいろ統一的に理解出来る。

5.11.3は良く書けているな。

## Part 1読み終わり

SVMとかの話とか、Deep Learningでは出てこ無さそうな最適化の話とか結構あった気がするが、あとの方で出てくるのか？
もし出てこないなら、そういうのを出すのはいまいちだなぁ、という印象。

ただ数値計算の所でsoftmaxとかlogのsoftmaxとか良くある話題で話をしているのは好感が持てる。

全体的に対象読者のレベルが良く分からないなぁ、と思うが、不勉強な学部生くらい向けなのかねぇ。
それにしては目次を見てると後半の内容は辛そうだが。
前半と後半で想定読者が違う2つの本がくっついてるのかもしれない。

Deep Learningが解決しようとしている課題についての理解はなかなか良い気がする。
さすがいろいろな事を知ってる人がDLについて書いた内容だな、という気はした。

あと参考文献がそれぞれの分野で定番な物をちゃんと挙げてくれるので、良いスタート地点になりそうで良い。

Part1は5.11以外は読まなくても良いかもしれないが、自分の理解している所、していない所を軽くチェックする目的で見ていくのは悪くない気はした。

# Part 2

Part 2は現状で一番使われてる定番のモデルの要素技術を説明する、という感じらしい。

目次を眺める限り自分の知らない事はあまり無さそうなので、軽く確認する位の気持ちで読んでいこう。

### XORの学習

今更な話題だが、最初からReLUなのは好感が持てるね。

ただこの辺の話はさすがにもういいだろう。

### 6.2.1.1 クロスエントロピーと最尤推定

6.12がクロスエントロピーの式だな、と思って説明を見ると、最尤推定だとの事。
ふむ、と少し考えると、対数尤度の期待値というのはクロスエントロピーなのか。

言われてみると当たり前だが、そういう認識では居なかったな。
KLダイバージェンスの最小化になってる、はPRMLでやった気がするので最大化問題としては同じなのはいいのだが、数式として解釈してなかったというか。

KLダイバージェンスの最小の条件が2つの分布が等しい、という証明をJensenの不等式から出すのをPRMLを読み直して納得したりする。

余談だが、前どこかでこの証明やったはずだが、ググっても自分のブログがひっかからん。ブログにしなかったっけかなぁ。

### 6.2.1.2 変分ベイズの話

なんか最初は分布全体じゃなくて条件付き確率だけでいい場合がある、という話なのに、唐突にそのあと変分ベイズの話を始めてて、つながりが良く分からんな。

なんにせよ、6.14が6.15になると言ってる。
6.14は条件付き確率をfと書けば、条件付き確率のpredictionとラベルデータの二乗誤差の、xとyの同時分布による期待値という式だ。

で、6.15はxの条件付き確率でのyの期待値、と言っているので、xをgivenとした時のyの期待値となっている、と言っている訳だな。

変分ベイズでそんな関係あったっけ？
変分ベイズってqとパラメータを交互に更新してく奴だよな、確か。あんま覚えてないなぁ。
まぁいいか。19.4.2でやるらしいので、そこで真面目に読もう。

6.15は条件付き確率の平均になってるので（分布では無くその統計量）、6.2.1.2の前半の話とつながってるな。なるほど。

ようするにこの節の流れとしては、

1. yの分布の形じゃなくて平均とかmedianで十分な場合がある
2. その場合は変分ベイズが使えて、cross-entropy とは違うロスの変分推定に対応する
3. だが、それはgrad descentと相性が悪いので、平均とかだけが要る場合でもcross entropy使っとけ

という事を言いたいんだな。

6.2.1はコスト関数の節なので、コスト関数の他の形の可能性の話をしている訳か。

## 6.2.2 Output unit

コスト関数の次はOutput unitの話か。
hまでとhからoutputを分けるのは、transfer learningをバリバリやってる身としては自然な分け方だ。

流れとしては

1. 線形
2. sigmoid
3. softmax
4. そのほか

と進むらしい。まぁsoftmaxか線形だよな。

#### 6.2.2.1 線形の場合

6.2.2.1でさらっと最尤推定が二乗誤差の最小化になってる、と書いてあるが、一応確認しておこう。

![](https://i.imgur.com/DIcMiN2.jpg)

雑にやればこんな感じか。

で、これとoutputを線形にする事の関係はなんぞや？

そうか。outputをhと線形の関係で結んだ時、このoutputは何を意味する事が多いかというと、正規分布してるようなyのmeanのpredictionの場合が多い、って事だな。

この時maximum likelihoodはcost関数として二乗誤差を選ぶのに相当する、という話か。

理論的な事を置いとけば、カテゴリカルじゃないなら最後は線形につなぐよな。
で、lossは二乗誤差だろう。
それを確率論的に解釈すると正規分布を仮定して最尤推定している、という話だな。

### 6.2.2.3 softmax

普通にzを線形にするとオーバーパラメとライズだ！と書いてあって、なるほど！と納得した。

でもそのすぐあとで「そうは言っても、そこはあんま問題にならないしオーバーパラメトライズな方が実装はシンプルだ」と書いてあって、俺のなるほど感を返せ！という気持ちになる(´・ω・｀)

### 6.2読み終わり

混合ガウス分布とかはPRMLでさんざんやったので後半はさらさら読める。
自作のoutputレイヤも、log likelihoodからコスト関数作れるぜ、というのは毎回感動するんだが、あんま使う機会無いんだよなぁ。

この辺の話はPRMLの方がずっと分かりやすいね。
ずっと読むのが大変だが。
一度ちゃんとPRMLやったかどうかが、こういう所で違いとなるのだよねぇ。

## 6.3 Hidden unit

ここはDeep Learningっぽい話題なので真面目に読む。
といってもReLUやLeaky ReLUは日常的に使ってるので別段なぁ、という感じ。

唐突なmaxout推し！へー、と思いながら読む。

こういう個々の要素の理解は全体をいじってる時に効いてくるかもしれんので、読む気にはなるね。

学習の為にlinearに近づけるというアイデアとしてLSTMも解釈出来るというのは興味深いな。なるほど。10.10でその辺の話をするとの事なので楽しみだな。

そのほかのhidden unitと何故最近使われないのか、の話も勉強になった。
6.3はなかなか良く書けてる節だね。

## 6.4.1 層の数の話

Universal approximation theoremの話から、ではなんで層が多い方がいいのか？という話。
これもなかなか良く書けていて勉強になる。

現在分かってる事、分かってない事、感覚的な解釈とバランス良くて、これを書いた人はDeep Learning良く分かってんなー、って感じがする。当たり前だが。

### Back propagationはさすがに飛ばす

ざっと見ていったが、読むべきものは無さそうなので飛ばした。
Hessianのあたりとか歴史とかは読んだが、あまり得るものは無かった。

# 7章 Reguralization

さすがにこの章は要らないかなぁ、と眺めていくと、意外と読み応えある所あるので、面白そうな所は読んでいく事にする。

### 7.1.1 L2 regularization

このregularizationの効果を調べる所がいろいろ計算してるので読む。
PRMLでpriorに関連している、というのはやった訳だが。

7.11式あたりで固有値分解をして解釈をいろいろしている。
やはりDeep Learningで必要な線形代数といったらこの辺は入るよな。
[機械学習をやる上で線形代数のどのような知識が必要になるのか](https://yoheikikuta.github.io/linear_algebra/)の話だが、って今見たら追記があるな。やはりこの位は要るやね。

で、なんか全然Deep Learning特有の話が始まらない。
章構成的にはここはDL特有の話を扱う章のはずだが…

### 7.1.2 L1 Regularization

こちらの議論はDeep Learningっぽさを感じるな。
feature selectionに使える、との話。

あんまり自分は使った事無いが、モデル圧縮とかやってる人達はこの辺の理屈を使うのかしら？

### 7.2 制約条件と考える場合

パラメータに有る種の制約条件を課すのは、キューンタッカー定理を適用する話となる。
これはイマドキなトピックだね。

パラメータに特定の範囲、という指定を加える事を関数空間をリプシッツ定数1以下に制約する事の近似とみなしたりするのはW-GANでやってる訳で。

理論的な話はあまり詳しくやってくれてないが、reprojectionという手段もある、というのは、へー、という感じ。
使った事無いが確かにこっちの方が良い可能性はある。
でもtensorflowでどうやって実装するのかしらね？

### 7.5.1 ouptutのターゲットにノイズを加える

このaugmentationって使った事無い気がするな。
最後のsoftmaxのターゲットを変えるだけで簡単そうだし、確かに効果ありそうな気がする。

### 7.8 Early stoppingの話

L2 regulrizationに一致する、という話はどこかで見た事ある気がするが、
頭の中で証明の筋が思いつかなかったので真面目に読む。

極限との差分の漸化式が7.37になるので、0からタウまで遷移させると7.40となり、タウを含んだ式で表せる。

あとはregularizationの極限と比較するお間の行列の値が同じになるようにパラメータが選べる、と。

さらなる近似でタウはL2 regularizerのパラメータと7.44の関係式で結ばれる。
感覚的には早く止める事はpriorから離れすぎない所に引き止めるのだから、こんな関係式があっても不思議じゃないやね。

### 7.10 Sparse representations

OMP-kって知らないな。
我らがNg先生がOMP-1が一番良いとおっしゃってるが。

気分的にはPCAみたいな物に見えるが、Wをどう学習するのかは良く分からん。
元論文読め、という事なんだろうな。

### 7.12 dropout

dropout boostingって知らないな。
この本の説明だけては良く分からんが。

ただ最近そんなにオーバーフィッティングしないんだよなぁ。
みんなtransfer learningでそんなオーバーフィッティングさせられてるの？
それって相当良いトレーニングセットが用意出来てるという事だと思うが、
そういう実サービスってそんな多くないと思うのだけど。

中間レイヤーが消える事の意味、みたいなのの話はなかなか面白い。
dropoutってそういう物だとなんとなくは思っていたが、ちゃんと文章にして解釈をまとめる事には意味があるな。

### 7.14 tangent propとか

tangent prop自体はPRMLの方が詳しいし、別段優れた説明とも思わないが、
adversarial exampleをヘッシアンをpertubationに強くするreguralization としてそれぞれの関係を理解するのは、そうか、こういう研究の延長でGANが出てきたのか、と思う。 

この辺のregularizationの話で、自身の業績をどういうコンテキストに置いて説明しているか、というのが読めるのはいいね。
Goodfellow御大のニューラルネットに対する理解みたいなのが見えてくる気がする。

そして関連研究も当然詳しいが自身もたくさん論文書いてる、というのは、当たり前だがトップ研究者とはこういうものだ、というのを見せつけられるな。
他人の論文RTするだけで自身の研究が無い、肩書だけ偉い人達とは一線を画す。
こうなりたいものやね。

トップカンファレンスに通すのはこのままでは難しいな、とか思ってる自分からすれば雲の上の話だが。

などとポエムとして読んでいたら、autoencoderがtangentを学習してる、
という話が出てきて姿勢を正して読み直す。
ふむ、興味深いな。14章が楽しみだ。

# 8章 Optimization

gradient descentの話をしたのだがらOptimizationなんてadamとかmomentumとかの話くらいしか無いのでは？と思うが、なんか大きく扱われてる。
へー。

### 8.1.3 バッチサイズの話

p272で、ミニバッチの典型的なサイズは32から256で、16が良く使われる、と書いてある。
へー、ミニバッチってワープを使い切れるように多めに指定しておくのが良いと思ってたが、こんなもんなのか。

一度のコンボリューションが16x16とかだとすれば、depthは4くらいあればまぁまぁなのか。
確かに16あれば2018年現在のGPUならだいたい埋まるかね。

[V100のSMの数は80個か](https://devblogs.nvidia.com/inside-volta/)。
で、1SMが最大64warp、スレッド的には1SMは2048か。
あれ？埋まらなくない？

まぁ前のmini batchの別のレイヤー計算したりするから別にこれでいいのかな。

mini batchの方が収束が早いというのは聞いていたが、こんな小さい方がいいんだ。知らなんだ。

そのあとにgradベースなら100とか小さなバッチサイズで良くてヘッシアン使うなら1万くらい要る、とか言ってる。
あれ？100で小さいって、さっき16くらいでいいって言ってなかった？なんかいい加減だな。

まぁこの手のはInception v3の原典とか、transfer learningの原典とか、使うモデルや手法の原典に従う方が良い気はする。

### 8.2.3 saddle pointとかの話

8.2.2の局所最適もそうだが、saddle pointが問題になる事ってあるのかしら？
全部のミニバッチがsaddle pointになるケースなんて実用上無いと思うのだが。

この項ではDauphineって人が良く登場するな。初耳の人名だがとんな人かしら？

### 8.2.7 局所的な性質だけの学習の限界

そのまま読んでいくと、8.2.7でそもそも極値にたどり着かない、という話をしてる。
そうそう、だから8.2.3の話とかはあんま重要じゃないと思うのだが。

8.2.7の最後のところを読む限り、

### 8.3.1 learning rateの指定

突然アドバイスが具体的に（笑）

そうそう、そんな感じで指定するよね、と思うが、これまでの細かい理論の話はなんだったんだ、という気もしてしまう。

### 8.3.2 Momentum

最近はいろいろ特殊なモデルをトレーニングする時はSGDが一番わかり易い振る舞いで使いやすい、というのが持論なので、momentumとかいまいち信用してないが、
いろいろ書いてあるのでちゃんと読む。

adamもそうだが、この辺の話はその当時のネットワークに最適化しすぎてると思うんだよなぁ。

## 8章はなかなか進まないなぁ

細かいところで割と先進的な話題を混ぜてくるので、8章はなかなかサラサラ読めない。
特に未解決な話はあまり知らないので、へー、そんなのがactive research areaなのか、と思いながら読むと時間が掛かる。

一方で掛けてる時間だけ何かを学んでるか？と言われると微妙。
難しい訳じゃないし読んでて面白いが、
これを読んだ結果を何かに活かせるかなぁ。

### 8.5.3 Adam

ここまでの流れからするともっと詳細な話があると思って読んでたら擬似コードだけで解釈の話があまり無くて驚いた。
著者の好みが出てるのかね。

### 8.6.2 Conjugate Gradients

Hessianの話って毎回実際は使えない、みたいな結論で終わりがちで、なんであるのかなぁ、と思ってたが、Conjugate Gradientsのnon linear版は使えそうに見える。
でも自分は使った事無いな。



### 8.6.3 BFGS

よーし、いい機会なのでBFGSちゃんと理解するぞ！と意気込んで読んだら、肝心のH inverseのupdateルールがLuenberger (1984)とか読め、となってる。

なんじゃそりゃ〜〜！

あんまこの辺使わないのでそこまで興味は無いよ(´・ω・｀)

まぁHのinverseを近似する方法以外の理屈はわかったので、理解したければそこだけ真面目にやれば良い事はわかった。
L-BFGSもどういう事をやろうとしているのかはわかったので、ブラックボックス感はだいぶ減ったな。

## L-BFGSなんで使わないの？スレ

Redditで、Deep LearningでなんでL-BFGSそんな流行ってないの？というスレを[見つけた](https://www.reddit.com/r/MachineLearning/comments/4bys6n/lbfgs_and_neural_nets/)。

ここから[The Tradeoffs of Large Scale Learning ](https://papers.nips.cc/paper/3323-the-tradeoffs-of-large-scale-learning)というBottouさんのnips-2007の論文が参照されている。
これはp288とかでBottou and Bousquet (2008)と参照されてるやつっぽいな。

短い論文なので読んで見るかなぁ。

### 論文の主旨

サンプル数を増やすと、小さいサンプル数とは違う性質のトレードオフが出てくるので、小規模で改善すれば良いってもんじゃないぜ。

### 論文の粗筋

トレーニングの誤差の期待値を、

1. 探索する関数空間の制約による誤差
2. 期待値をとるサンプル数の少なさから来る誤差
3. 与えられたサンプルに対する近似誤差

の3つに分けて、最適化問題を、

1. 使うサンプル数＜持ってる全サンプル数
2. アルゴリズムによる計算時間＜使える計算時間

の2つの制約条件化の最適化問題とみなす。
サンプル数を増やせる状況（つまり計算時間がbound）なら、より不正確で単純なアルゴリズムでサンプル数増やす方が良い場合もある。

なお、タイトルにもなってるLarge-scale learningの定義は、2がバウンドな問題、との事。

論文は線形でリプシッツ定数B以下の関数空間についての解析的な議論で、実験は特に無い。
比較対象はHessian使ったsecond order gradient descentで、Conjugate GradientとかL-BFGSとかでは無い。

### 論文雑感

個々の上限は別論文参照となってる。
実際極限定理の収束の速さは結構難しい実解析の領分のはずなので、この短さではどうこう出来まい。

結果を何も考えずに受け入れると、議論の内容自体はDeep Learningでも適用出来そうな素直な内容と思う。

ただ、前提は結構微妙でサンプル数はどこまでも増やせる、というのこそがlarge  scale だ、というのはどうかなぁ。
モデルがでかい、という場合もlarge scaleとしてはあると思うが。

特に学習困難な超解像度みたいなのの類だと、なかなか最適なところまで行かない、みたいなのが問題になりがちで、単純なアルゴリズムでサンプル数増やすと改善するか？というと全然しないよな。
そういう点でupper boundで議論するのは学習の難しさを隠してしまっていて、BFGSが有効でないという議論にはなってない気がする。

### On optimization methods for deep learning

菊田さんから[別の論文を紹介してもらう](https://twitter.com/yohei_kikuta/status/1001281339763519489?s=19)。

こちらは実験してみてL-BFGSの方が良い場合やConjugate gradが良い場合もある、という結果を出している。

Andrew Ngさんの名前が入ってるのでそこの研究室の仕事っぽい（からGoodfellow御大ももちろん知ってるだろう）。
こちらは2011年でCNNの話ではある。

内容としてもSGDの学習しづらさがモチベーションとなってるので先の論文よりも今の現場の問題意識には近い気はする。

この論文をざっと読んだ印象では、複雑なモデルでConjugate Gradientは試す価値がある気がする。
SGDでうまくいかない時は試してみよう。

## 8.7 Batch Normrization、他

本に戻って。

8.7.1にBatch normarizationの話があるが、
文章は多くても実際に実装する時の話が全然無くて驚く。
重要性を考えたらもうちょっと実装の話もあって良いと思うのだが。

以下の人工知能学会の深層学習本の4.3.4の方が短くてもyの方の式もちゃんと載ってて実装は分かりやすい。

<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=qf_sp_asin_til&t=karino203-22&m=amazon&o=9&p=8&l=as1&IS1=1&detail=1&asins=476490487X&bc1=ffffff&lt1=_top&fc1=333333&lc1=0066c0&bg1=ffffff&f=ifr"> </iframe>

goodfellow本もp312にガンマとベータの話は出てるが、文章の中に埋もれてる。

### 8.7.4 Transfer learningとかの話

実践的には非常に重要なtrantfer learningの話が軽く紹介されている程度で、この記述だけでは使えそうにない。
これはどうなのかなぁ。

とりあえず使う時の参考書として使う事を意識してないのかなぁ。
ここまではとりあえず使いたい人の事にも配慮した本なのかと思ってたが。

### 8.7.5から先 学習しやすいモデルとか

skip conectionとかの話があるが、
これではいまいち良く分からない。
うーん、この辺のResNetやInception v3やv4の工夫とかは知りたいところだと思うけどなぁ。

8.7.6はContinuation Methodsとカリキュラムラーニングだが、ここも言葉で概要が説明されているだけ。
この辺は結構興味ある所なので残念。

Deep Learningではあまり問題にならないような事を擬似コードとか詳細に説明しつつ、この辺の応用で重要な進展をあまり説明しないってのは、どういうモチベーションなのかね。
まだまだ出てきたばかりなので教科書にする程枯れてない、という事なのかもしれないが。

# 9章 CNN

CNNの構成要素の説明をする章らしい。
ネットワークアーキテクチャの話はしない、とのことだが、それだとなんの話をするのかしら？
1x1 convolutionとかの話はあるのかな？

### 9.1 、9.2 Convolution

NNは歴史的な話をたくさんしてたのに、Convolutionではガウシアンフィルタとかの画像処理の歴史的な話が無い。
なんか不思議なバランス感覚だな。

しかも内部がどう学習されていくか、みたいなお決まりの話も無い。ふーむ。

入門としてわかりやすくも無いが大して深い分析も無い。Convolutionの説明は単にいまいちだな。
[stanfordのCS231n](http://jbbs.shitaraba.net/bbs/read.cgi/study/12706/1494591119/)の方がだいぶ良い気がする。

### 9.3、 9.4 Pooling

Convolutionはいまいちだったが、Poolingは良く書けてるな。なんで？

解釈的な事も割としっかり書けていて悪くない。
ただこれではpoolingはパラメータが無いってのは読んでて分からない気がするな。
実際にモデル触るのに必要な情報は足りてない気がする。

### 9.5 Convolutionの亜種

何故か9.3と9.4でpoolingの話を挟んだあとでconvolutionのstrideとかの話に戻る。なんで？
なんか章構成おかしくない？
9.2の次にする話だと思うのだが。

しかも足のnotationが多重定義されてて大変読むのが辛い。こういうの強い人はスラスラ読めるのかねぇ。

validとsameとfullの話があるが、これもなんか文章でひたすら説明されてて並列構造も分かりにくい。大した話じゃないんだから式とか図とか表とかでパパっと終えて欲しい所だが。

Fig 9.14とか9.15の、unshared convolutionとかチャンネルの接続を制限した奴の話は分かりやすいな。
あんま使わない奴の解説が分かりやすいのは、
この分野に詳しい人には嬉しい。
初学者に薦める本という気はしないが。
自分は初学者じゃないので素直に喜んどこう。

***Tarnspose Convolution***

Transpose Convolutionというのが出てきたがあんまり良く知らない。
説明を読んでもわからないのでググる。

- [Up-sampling with Transposed Convolution](https://towardsdatascience.com/up-sampling-with-transposed-convolution-9ae4f2df52d0)
- [An Introduction to different Types of Convolutions in Deep Learning](https://towardsdatascience.com/types-of-convolutions-in-deep-learning-717013397f4d)

上の方が理屈が分かりやすい。下の方がコンテキストが分かりやすい。

とにかく逆変換じゃないが似た物をつくる為のconvolutionなのだな。

## Multidimensional Downsampled Convolution for
Autoencoders

お、本文に戻って読み進めると、transpose convolutionとかの詳細はGoodfellow 2010を読め、と書いてあるな。

[Technical report: Multidimensional, downsampled convolution for autoencoders(pdf)](http://www.iro.umontreal.ca/~lisa/pointeurs/convolution.pdf)

これか。
一応軽く読むか。

### abstract

convolutronal autoencoderを実装するには

- transpose
- gradient
- transposeのgradient

が必要になる。だいたいはconvolutionの亜種として実装出来るがもとがdownsample の場合は2つほどあらたな演算が必要になるよ。

### 1. Definitions

これも足が多重定義されてて辛い。これがGoodfellow流か…

以下のHの定義の式、

![](https://i.imgur.com/dPgAI7G.jpg)

このHの式の文字で、足の意味を考えると、

- c: 空間的位置
- i: feature mapのインデックス
- j: サンプル
- k:  weight の空間的位置、フィルタの大きさの範囲で和を取る
- m, i: Wの、入力チャンネルmからhiddenのチャンネルiへの接続。mもフィルタの範囲で和を取る
- d: ストライド

という事か。

Hはhidden、Wはweight、Vは入力。

### 2のgradientが良くわからない

さて、コスト関数をWで微分した式を計算して、それについての議論をするが、良くわから無い。

まず、Lの微分の計算は良い。
結果は以下になる。

![](https://i.imgur.com/aobScV4.png)

分からないのは、これがdが1なら次元を入れ替えたりするとconvolutionに出来るが、
dが1じゃないと出来ない、という所。

別に1じゃなくてもconvolutionのような？

具体的に置き換えを考えてみよう。

![](https://i.imgur.com/NXSzIjR.png)

と置くと、

![](https://i.imgur.com/GmKp7JH.jpg)

次にiとjを入れ替えて取り直すと、

![](https://i.imgur.com/YwfbsYS.jpg)

あとはVの足を…ってそうか。
convolutionでは和のとり方は1ずつずれてくから、dが1じゃないと置き換えでは同じに出来ないのか。

なんかこの和のとり方を飛び飛びにするパラメータもあったよな。名前忘れたが。

まぁいい。納得した。

### 3以降の話

3はTranspose。

これはさっきググった内容から何を言ってるか分かる。
ちゃんとは追ってないがまぁこんな感じになるよね。

結局残りは、5. Autoencoderで定義される式のgradをひたすら手計算してるだけに見える。
convolutionとして表せたり表せなかったりするが、ほとんどconvolutionをちょっといじっただけなので、これ、普通にcompute_gradで出るんじゃないのかしら？

手計算するモチベーションは良く分からない。

### まとめ

- downsampleのconvolutionの逆っぽく振る舞うconvolutionみたいなのを、行列をreshapeしてTransposeすると出す事が出来る
- それはhiddenからinputを再現するとかautoencoderとかで使われる

追記: わかった、これ2010年だから、まだcomputation graphから自動微分とかが一般的じゃないのか。
だから手計算してMATLABとかで実装してたのか（たぶん）。

でもなんでこの本にそんな昔の話を含めるのだろう？

---

本に戻って。p346で、今読んだ論文の話の単純なケースの計算をやってるが、
これだけ読んでも意味が分からないだろう…
一応自分はさっき読んだので解説しておこう（誰の為に？）

まず、先程の論文で、Convolutionの微分を解析的に計算すると、演算としてはConvolutionを少し拡張した物になってる、という話がある。

で、それを簡単な例で手計算で試してみよう、というのがp346の式9.13までの話だ。
この前提が無いと突然back propagationの計算だけしてほうりっぱなしジャーマンでポカーンだよ。

式9.11は先の論文よりはだいぶわかりやすく書こうという意思が感じられる。
ただここまでやるなら下の9.12と9.13ももう少し解説があって良いんじゃないか…

式9.12から9.13は式9.8とchain rule使う。

で、式9.13はシグマの所が小細工が入ってるので厳密にはconvolutionじゃないが、かなり似た式になってる。しかもsが1なら厳密にconvolutionになってる。
だからこの9.5で扱っているのだろう。

ただCUDAくらいの自由度がある世界なら、これがconvolutionと似てるからなんなの？という気はするな。
Tensorflowとかなら、conv2dとかのカーネルとしてgradも一緒に登録されるので、その内部の実装の話となる。

2010年なら自分で実装してたから、こんな演算を作ってそれを呼び出す事で、汎用のAutoencoderモデルの記述の為のビルディングブロックが作れます！という話だったと推測。

9.13式の次からはautoencoder の話になってる。
突然話が変わるので混乱しやすいと思うので注意。

で、autoencoderをPCAと同じような物をCoevolutionのような物で実装して学習させる、と考えるとtranspose convolutionという物が出てくる、という話をしている。

それがどういう物かは先の論文を見てもらう必要があるが、普通のconvolutionの逆演算に近くなるようにkernelのtransposeを並べる感じだ。
それをhという関数で置いている。

すると、このg, c, hの3つで必要な演算はそろって、この3つは形上はConvolutionをちょっと変えた物なので、Convolutionの亜種の応用例としてここで解説している。

以下は余談だが、どうせならhの定義も書いてくれよなぁ、という気がする。
この中途半端さはなんなのだろう。

### 9.9 Random and Unsupervised Features

CNNの前半の方のfeature extractionのあたりの学習のいろいろな手法の紹介。
ただ論文名と一言コメントだけが列挙されてるだけなので大した話では無いが、
自分の知らないのもたくさんあって、
この辺でアイデアが必要な時には良い解説に思う。

などと感心してたら、この辺の手法は2007〜2013年くらいに流行ってたが、「最近は教師データも多いしcomputing powerも多いから普通にfullのback propagationで学習するよ」と書いてあって、がっかり。

ただこういうのはまた必要になる事もあるかもしれないので、こういうまとめには意味があると思う。

昨今は画像識別に関してはpre-trainedな最強モデルを使う以外の選択肢は無いので、
それをどう作り上げるか、という話は知る必要は無いし、ほとんどartの世界なので知る事もそもそも出来ない。

だが、それらを別の用途、例えば超解像度とかに応用しよう、というと最初は小さなCNNとかから始める訳で、
そういう時にこういう引き出しを多く持っておくのは結構役立つよなぁ。

### 9.10 neuroscientific basic for CNN

単なるポエムかと思いきや、意外と良く書けている。

Gaborフィルタとか昔の論文と比較する為に実装する事あるので、こういう背景知ってるといいよね。
自分が調べた事と同程度には良く書けているので、これを先に読んでいたらなぁ、という思いはある。

こういう、ただモデル持ってきて動かすだけでは使わないが、実際に論文書く時必要になる背景知識みたいなのが載ってるのは好印象。
たまたま自分の経験に当たらないと必要性は分からないが、これまでの今更不要に思える話もたくさん論文書いてる人なら必要性が理解出来るのかもしれない、
という気分になった。

# 9章まで読んだ感想

[別エントリ](https://karino2.github.io/2018/06/04/218.html)にした。

# 10章、RNNとか

さて、10章を読んでいきましょう。

LSTMとかは以前読んだ事があるのだが、当時知りたい事が載ってなくてあんまり印象良くないが、ちゃんと章の最初から読むとどうだろう？

## RNNの参考書

詳細はGraves 2012を読め、とある。
リファレンスを見るとSupervised Sequence Labeling with Recurrent Neural Networkとある。

少しググると[著者のページ](https://www.cs.toronto.edu/~graves/)に行き着く。
preprintのpdfが公開されていそう。

軽く読んで見る事にする。

### Sequence Labeling

シークエンスデータからラベルのシーケンスを生成する問題をSequence Labelingというらしい。

で、著者は音声認識でLSTM使う為の手法を編み出したようで、その話の模様。
connectionist temporal classificationと言うらしい。へー。

従来手法はRNNの次にHMMつなげるようなハイブリッドモデルだったらしい。
確かに音声って音素ごとにトレーニングデータがあるとかじゃないので少し細工が要りそう。

という事で、なんかあんまRNNの本じゃないな。
もう少し読んでみよう。

### RNNの解説はありきたり

RNNは今となっては見慣れた展開の話とかだけで、自分がいまいち良くわかってないあたりの話はなかった。

むしろこんな昔からこの解説あったんだね、と思う位、昨今良く見る話だ。

###  CTCの話も興味が無ければ読む理由は無い

軽く読んでみたが、現在のデファクトとなってるEncoder-Decoderが発明される前の手法なので、
もっと良いやり方を知ってるのに昔のめんどくさいトリックを学ぶ感じになる。

RNNを知りたいと思ってこのpdfを読んだのは失敗だった。
本に戻ろう。

----


## 10.1 unfolding

RNNって必ずこの展開の話があるが、これって毎回良く分からんのだよな。

パラメータの共有が分かりにくくなるので、トレーニングの時に何が起こるのかが感覚的に分からなくなる。

GPU上のメモリに記録されるもの、ホストのメモリに記録されるもの、一時的な値、とかの区別も分かりにくくない？
みんなどう理解してるのかなぁ。

### なかなか良く書けている

などと思っていたら、その先にもっと細かい説明があった。10.6式とか。
そうそう、こういう風にいろいろな角度から見ていかないと分かる訳無いと思うのだよなぁ。

言語モデルとかはこの解説では分からないだろうし、HMMの経験無くてこの説明で理解出来るとは自分は思わないけど、
それでも世の中に出回ってる説明よりは難しさをちゃんと説明してて偉い。

## 10.2 RNN

冒頭にfoward pathとロスの話が書いてあるが、凄く分かりやすい。
10章は良く書けてるな〜。
CNNの出来の悪さと対照的だ。

10.14式で、対数尤度の和をロスとするとさらっと流してるが、こういうのちゃんと理解するにはどこかでPRML的な本での訓練が要るよなぁ。
せめて10.14式の和がデータの分布による期待値になってる、
と書いてあれば、クロスエントロピーという理解が深まると思うのだが…

ただ自分のレベルならこれで十分詳しいので、自分としては好印象。

### Teacher forcing

おぉ、これ、teacher forcingという名前なのか。
良くやってたが、名前は知らなかった。

このトレーニング時とprediction時で見る物が変わる問題は毎回苦しむ事になるので、この辺の話がちゃんと書いてあるのは偉い。

ランダムに切り替えたらいいんじゃね？と思いつつ読んでたら、2015年にBengioがやってた。さすが。

### 10.2.2 gradの計算

BPTTの2期とか3期くらいをあらわに手で計算しないと分からないなぁ、と前から思ってたので、ここで手計算してみようかなぁ、と思い読む。

まず10.17はほぼ自明だが、ここからやろう。
ロスは10.13式にあるように、個々の出力のロスの和になってる。

で、個々の出力のロスは実際のデータの分布とのクロスエントロピーだ。

10.18式でiという物が出てきている。
これはyの何番目の要素か、つまり次元を表すのかな。

ちょっとここまでの暗黙の仮定をちゃんと書いてみよう。

まずは出力のsoftmaxをyのpredictionとする、という事から、

![](https://i.imgur.com/spIT6J2.png)

となる。
これは例えば考えられる単語の種類、つまりいわゆる語彙数が5だったら、

![](https://i.imgur.com/9U6EneQ.png)

みたいなベクトルになる訳だよな。全部足したら1になる。

それに対して、真の値であるy、つまりハットの無いy は、どれかが1のベクトルだよな。

![](https://i.imgur.com/m0fqvv3.png)

で、lossはinputをgivenとした時の真のターゲットのマイナスの対数尤度との事。

尤度は分布がyハットの時、yが得られる確率みたいなもんだ。
この場合はいくつだ？

あー、そうか。これをoの要素で微分したいのだから、要素ごとに出すんだな。
つまりこれはベクトルになるのか。

真の値が1の所と0の所で式が変わりそうだな。

まず0の所をいくつか見てみよう。一番上の要素が0になる尤度は、

![](https://i.imgur.com/NCWXyZg.png)

あー、だいたいわかった。

|真の値が0の成分|1-yハット|
|真の値が1の成分|yハット|

だな。
で、全要素がこの観測値になる確率は、積でいいか？

これを式で書くには、if文っぼい事を0乗と1乗で実現するんだよな。

つまり、「1-yハット」と「yハット」の積にして、どっちかだけが1になるようにするんだっけ。

![](https://i.imgur.com/Ba6ibjh.png)

こうか？なんかこんな感じな気がする。

で、対数尤度にマイナスをつけたのがロスなんだから、

![](https://i.imgur.com/7F9wAii.png)

こうか。これがLtだな。

さて、これを元に10.18を計算するが、Lをoで微分するには、結局yハットをoで微分する事になる。

という事でそちらを先に計算すると、

![](https://i.imgur.com/xQk1efQ.jpg)

となりそう。あとはLの微分の式に代入すれば出そうだな。

![](https://i.imgur.com/9zSqOun.jpg)

あとは真のyの値をクロネッカーデルタ、、、じゃなくてidentity functionで書けば10.18になりそうだな。

うーむ、結構ゴツいなぁ。やっぱりPart 1と難度が揃ってなくない？
自分はこのくらいなら行間埋められるから、自分くらいの理解度向けの教科書なのかね。

さて、oによる微分を計算したので、次はhによる微分だな。
hによる微分まで出れば、あとは通常のback propagationなのでhまででいいかしら？

hの絡む式は10.8〜10.10だな。

![](https://i.imgur.com/ffNouKX.jpg)

図の10.3から一つのセルの周りだけ抜き出すとこうか。

![](https://i.imgur.com/4KBjtUh.jpg)

端だったら式10.10を使ってチェインルールで出そうだな。
簡単の為、一番最後の時点、つまり10.19のタウを10としよう。
10個の入力がある場合。

この時、10番目は式10.19になる、、、と思ったが、なんでVは転置なんだっけ？

行列のパラメータを持つ場合のgradはTが出るんだっけ？と2章を見直すと行列のgradが無い！2章の内容じゃ足りてないじゃん！
これなら2章要らないよ…

こんな時はPRMLだ。

<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=qf_sp_asin_til&t=karino203-22&m=amazon&o=9&p=8&l=as1&IS1=1&detail=1&asins=0387310738&bc1=ffffff&lt1=_top&fc1=333333&lc1=0066c0&bg1=ffffff&f=ifr"> </iframe>

p697の式C.19に、

![](https://i.imgur.com/DkpL47U.jpg)

というのがある。持ってて良かったPRML。

この手の公式は成分を地道に計算するとこうなります、だからあんま証明とかやる気は起こらないが…

以下、ベクトルを縦に書く事にする。

積を計算する為にはaは転置する必要があるよな。
でも掛けた結果のgradは、縦に戻る訳だ。

つまり、aの転置がaに戻る。

さて、ではaが行列だった場合はどうか？

![](https://i.imgur.com/rZfnIWW.jpg)

あら？微妙に転置にならない。というのは、この最後の式は、aベクトルも縦なので、こういう感じだ。

![](https://i.imgur.com/D4NTVvu.jpg)

あれ？おかしいな。行列の転置にならない。  
まぁこのまま計算してみよう。

![](https://i.imgur.com/0j837Dw.jpg)

かったるいが、Vの転置の転置の転置になりそうかな。

どこかに計算ミスがあるかもしれないが、理屈は納得した。
チェインルールで10.19になりそう。 
納得する為にやってるのでこれで十分だろう。

先に進もう。

さて、ようやく本題だ。
最後の要素は式10.19で良い。
我らは最後を10番目とする事にしたので、10期目はこの式だ。

では9期目はどうか？h(9)をちょっと変化させると、h(10)を通してL(10)にも影響を与えそう。

10.8と10.9式を使えば、

![](https://i.imgur.com/iEd2fBj.png)

と書けて、h(9)によるgradは、

![](https://i.imgur.com/XTI8CdG.png)

となる（本当は転置とか書いていかないと辻褄合わないと思うがさぼり）。
これが10.20式と同じものか。

o(9)によるgradは昨日計算した10.18。
h(10)によるgradはさっき計算した10.19で、右側の方の係数は10期と同じ形になるだろうから、残るのはh(10)のh(9)による微分。

これはtanhのヤコビアンになりそうだが、そんな計算は辛いのでやらない。
本文にはtanhのヤコビアンは対角行列で書けると言ってるので素直に信じる。
ゆとりなので！

そうすると10.21になるとの事。ここまで計算すれば転置とかはこんな感じになりそうなのは感覚的には納得出来る。

### 10.21式の含意を考える

さて、計算すると10.21になりそうなのは納得出来たので、その含意を少し考えておこう。

カッコがフリックで入力するのかったるくなってきたのでh(9)をh9と呼ぶ。

h9をちょっと変えると、o9がちょっと変わってL9が変わるのは当然だが、
さらにh10もちょっと変わるからo10もちょっと変わってL10もちょっと変わる。

だから過去をいじる時はいつもそこからの未来への影響も考慮に入れる必要がある。これがforward pathから考えた話だ。

つまり、h9というのは、o9とo10の両方がいい感じになるように調整しないといけない。
感覚的には関数的平均を求めたい。
関数的、というのはinputはx9とx10で別物だから。

で、例えばx11とy11が追加されたとすると、理想的なh9は変わる。
というのは、o9とo10だけじゃなくてo11もベストな物を出さないといけないから。
だからo9とo10とo11の関数的な平均みたいな物に変更しないといけない。

ただ、o9とo10とo11はrecurrentな関係になってるので全部同じ関数という訳じゃない。
一つの重みから3つとも生成しなきゃいけないけど、同じ関数では無い。

感じとしてはo9を$$W x$$で、o10を$$W^2 x$$で、o11を$$W^3 x$$で作る感じだ（もちろん間にもっとtanhとかいろいろ挟まるので全然違うが）。

一つのhの影響ですらこんな複雑なのだから、その全てのhをベストにするWの探索というのは相当難しそうな気がする。

そう考えるとtransformerモデルの方が良さそうだよな。
positional encoding埋め込んだCNNでhiddenを計算して、アテンションつけてdecodeする。
筋の良さの感覚をつかんでおくのは大切やね。

お、なんか今回はちゃんとわかった気がする！
この計算やるの5回目くらいな気がするが、
これまではいまいちわかった感じがしなかったんだよなぁ。
実装したりコード読んだりしたあとだからかもしれない。

---

話を教科書に戻すと、hの微分が出たら、あとはパラメータの微分は簡単なのでいいだろう。
10.22から10.28までは計算すれば出る。

### 10.2.3 graphical model

conditional independenceとかさらっと出てくるが、この本読んでるだけじゃ何言ってるのか全然分からんよなぁ。
PGM大好きっ子としては嬉しい項だが。

Markov assumptionとの比較とかはいいね。そうそう、RNNってこういう事だよね。

そしてxを無くしてyだけのGraphical modelを考える、というのも良いね。
こういう解説要るよなぁ。
さすがにGoodfellow御大はRNNの理解が深い…

hをrandom variableとみなしてtabular represetationを考えてみよう、ってめっさ[PGMを思い出す](http://jbbs.shitaraba.net/bbs/read.cgi/study/12706/1466006216/)な(^_^;)

なんらかのstationary stateの仮定は自分もそんな気がしてたのだよなぁ。やっぱそうか。よしよし。

そしてPGMから生成モデルの話につなげるのもなかなか深みがあって良いね。
やはりこの章は凄く良く書けてるなぁ。

EOSを入れる方式しか知らなかったが、Bernoulli分布で続けるか判断するなんて手法もあるのか。知らなんだ。
確かに離散的じゃないとEOSに当たる事は無いだろうからこうする必要があるやね。

そして長さをpredictするという手法も面白い。Goodfellowは2014年にこんな事もやってたのかぁ。

### 10.2.4 xの条件付き確率としてPGMを考える

さて、お次はxを入れて考える、という話。
この時はRNNで表現出来る関数スペースとはどんなものか？という話になりそうな気がするがどうだろう？
読んでいこう。

まずxが全タイムステップで一つの時を書いている（図10.9）。
この時は入力の方が単なるバイアスパラメータとなる、と言っている。
これは式10.8を見れば明らかだが、グラフィカルモデル的にも見慣れた形。

こうする事で、10.2.3項でやったモデルのバイアスを入力でパラメトライズするようなモデルに拡張出来る。なるほど。

さて、我々の本来のモデルはxがtime  stepごとに違う物だ。
だがそれを単に入れるとRNNの制約が入らない。
RNNとしては10.35式のような条件付き独立の制約があるのでそれをPGMに反映する、という話をしている。

10.35式とはなんだろう？

まず、ytはxtまでにしか依存しない、というのは分かる。つまり、

![](https://i.imgur.com/H5dE3Vv.jpg)

とfactorize出来るまでは良い。
この時点でのPGMは、

![](https://i.imgur.com/079RZtN.jpg)

となるか。y同士の矢印の向きはいろいろありうるが。

で、このy同士の接続は普通のRNNより多すぎるな。適当なd-sepを入れたい。
conditional independenceとしては、xの前の期の影響はhを通してしか来ない事と、前のyだけに依存する事を入れたら良いのかね。

![](https://i.imgur.com/KSjKhip.jpg)

これなら10.35の形でfactorizeされるはずだが、なんか図10.10とは違うな。

図10.10の解説では、図10.3ではyがconditionally independentじゃないといけない、とあるが、式10.35はまさにyがconditionally independentだ、という式じゃないか。

ああ、そうか。10.35からさらにconditionally independentの仮定を取り除くためにエッジを足そう、という話か。誤読していた。

この10.10は先程私が書いたfactorizeの式やグラフィカルモデルとどう違うか？
Lやoがあるのは除いてhを加えたとすると、ytとh(t+2)とかとのコネクションが無い所が違うか。
こうしておかないとhによるd-sepが実現出来ないので、こちらの方がよりRNNとしては正しいね。なるほど。

これが一番一般的なRNNの形かな。
10.2.2項より複雑なケースを考えてる、というのは章構成的に問題ある気もするが、PGM好きとしては10.2.4は理解が深まって良かった。

## その後の話

続く10.3と10.4節はBidirectionalとかEncoder Decoderとか。

どちらも短く簡潔だがこんなもんで良いな、という内容。なかなか好印象。
やはり10章は良く書けているな。

attentionとかは12章らしい。

10.5はDeep RNNs。

ごてごてつなげた結果のアーキテクチャは見る機会多かったが、こういうふうに個々の複雑さの要素を見た事はなかったので勉強になる。
Bengio 1996か…

10.7はLong term dependencyの難しさ。

良くある勾配消失とか爆発の話だけど、
ここまでの説明と良く整合性が取れてて良い解説だなぁ。
この章はほんと良く書けてる。

10.8はEcho State Networks。
名前は初めて聞いた気がするが、
初期化を似たようなやり方でやる、というのは良く見かけるので、
たぶんこの研究に影響を受けたモデルは現在普通に見かける物なのだろうね。

ただ10.8節の解析的な話は割と詳細で、8章で出てきたヤコビアンとかちゃんと使ってるのは好印象ね。
準備した物は使ってほしい。

線形の例でまず見ていく、というのはやっぱいいよな。
こうやって理解を積み重ねていく事で、何をやってるかを感覚的に知ろうとしていくのは実務でも大切と思う。

固有値の指数乗で減衰しちゃうのは期待してる挙動じゃないよなぁ。
人間の感覚的には、一定以上遠い物は遠い物同士の一定の関連を持つと思うのだ。
だから最初ぐわっと減衰したあとは一定の所で落ち着いてくれる方がいいよな。

これは関数がrecurrentなのが良く無いのだが…ってそれはまさにLSTMか。

spectral radiusを制約しておく、というのは、リプシッツ定数を制約しておくのと似てるよなぁ。
この辺は奥が深そうなテーマな気がする。
概念的にはregularizationの一種なのか？

### シーケンスラベリングのモデルの話（雑談）

昨今は、画像認識、例えばResNetとかInception vなんちゃらとかMobileNetsとかを自分で作ろう、という気はあんまり起こらない。複雑過ぎて。
ImageNetへのオーバーフィッティングとかはあるので、実務のレベルで改善は出来うると思うけれど。

それよりはこれらのモデルは所与とした上で、transfer learningとかでその先のモデルを設計していく方が楽しそうに思うし、実際前回の自分の仕事もそういう物だった。

でも系列データの方のモデルに関しては、まだ結構いろいろ考えて作って、現在の最強モデルをout perform出来る気もする。
実際transformerモデルはあんな小さいのにout performしてるし、いろいろと疑問に思う部分は残ってる。

NLPとかは自分のアイデアでいろいろ作っていく、というのもアリな気がするね。
定番が出来て規模で殴るフェーズにはまだたどり着いてない気がする。

---

本文に戻る。10.9はskip connectionとかLeaky unitというものの話。
Leaky ReLUみたいなのをイメージしてたが全然違った。

この辺の話はあんまり知らないなぁ。90年代とか古いのも多いが、最近はどうなんだろう？
この本の説明だけだと良く分からない事も多いが、読んでみたいと思う論文や本も無くて悩ましい。

### Leaky Unitの論文を読む

LSTMの所を読んでたらLeaky Unitsの発展として説明されてたので、Leaky Unitsの論文を読む気になる。

Mozer 1992とEl Hihi and Bengio 1996の2つが挙げられてるが、El Hihi とBengio 1996を見てみたらhierarchical  RNNで、なんか違う話してるようにしか見えない…

Mozer 1992を読む事にする。Introdution  to  Multscale Temporal Structureという奴っぽい。

1992年にこんな話してたのか！俺中学生だよ！内容的にも今どきっぽくてビビる。
この時代にこんなのやってたのに割と最近までHMMが全盛だったんだよなぁ。

読んでいくと、どうも1の(1)式くらいしかモデルの説明が無い。
net(t)はなんだろう？
input layerからとrecurrent context connectionからの両方のnetのインプット、との事だが。

RNNでtanhに食わせる物と言えば、本で言う所の10.8か。つまり、

![](https://i.imgur.com/Dg2BXdl.jpg)

という事か。違いを見るべく通常のhの更新式も載せておく。10.9式です。

![](https://i.imgur.com/Gftn0X1.jpg)

つまりどういう事だろうか？
感じとしては移動平均みたいになるんだよな。
ようするにhidden stateをならすのか。

こんなもんでいいか。

## 10.10 LSTMとか

みんな大好きLSTM。最近はあんま見ないけど。

10.40から10.44式がLSTMの式。もう見慣れた物があるが。

パラメータが多いが、もう一段大きな視点で何をやってるか見るのが大切。
ゲートとかのレベルで考える。

ゲートというのは、入力と前回のhを引数にして0-1を出力する関数。
これは基本的にはロジスティック回帰をやってる訳だよな。
どういうロジスティック回帰かといえば、その掛けている要素を残すか捨てるか、というロジスティク回帰。

で、10.41は先程のLeaky Unitと似た形になってるが、タウをforget gateに置き換えてる。しかもsとhは違う物にしてる。

で、インプットとsを別と考えてLeaky Unitsみたいな事をゲートでやる。
平均では無くて別々のゲートで、外からのシグナルを受け入れるか、と、中のステートを持ち越す、というのを足した物。

これ、sがどんどん大きくなる事ある気がするがいいのかな？まぁ最後はtanhだからいいのか。

で、hをsとゲートを掛けた物として、あとはだいたい普通のRNNか。

昔見た時は随分複雑に見えたが、今見ると割とちゃんと個々の式の意味が分かるな。

成長したヽ(´ー｀)ノ

### GRUs

みんな大好きGRUs。
Leaky Unitsを見たあとに10.45を見ると、結構似た印象だな。

感覚的にはuはタウだ。
移動平均の具合を決める。

で、rというのが追加されてる。reset gateというらしい。

これは通常のRNN的にhを計算する所でh(t-1)をたまに無視するように振る舞う。
このrの方の含意は分かりにくいなぁ。

今回はhは忘れる、ただし一回だけ！という感じの挙動か。

説明を読んでいくと割と自分が感じた事と同じような事が書いてあるので、自分の理解は割といい線行ってそう。

## 10.12 Explicit Memory

これ、[以前わりと元論文を真面目に追った事がある](https://karino2.github.io/2017/12/24/125.html)のだが、どの辺がメモリか良く分からなかったんだよなぁ。

ここでGraves 2014bというのでneural  Turing machineというのが紹介されているので読んで見るか？

これか。

[arXiv: Neural Turing Machine](https://arxiv.org/abs/1410.5401)

最初の方だけ読んで見たが、なかなか良かった。

最終的なモデルだけ見るとどこらへんがメモリなのか全然分からんのだが、モチベーションとかやりたい事とかから見ると、なるほど、メモリとはこういう事をやりたいのか、と腑に落ちた。

2章のポエムっぽい所をちゃんと読むのはこの辺分からん人にはオススメ。


### 3.3.2 wの作り方

content basedとlocation basedはモチベーションは理解出来た。

式7とかはLeaky UnitsやLSTMと同じ発想なので良かろう。

location  basedのsを作る所のメカニズムはなんか良く分からないな。
どれだけシフトが許されるかをemitするって、なんでそんな局所的なんだ？

ただ位置をemitするのも試した、と言ってるな。こちはは何をやってるかは分かりやすい。

あ、そのあとの式8の所で例を挙げてるのでわかった。
移動できる範囲ってのは、移動する点と、その周りにぼやっと広がる正規分布か。ようするに移動先なんだが、多少スムージングするだけね。

で、式8はconvolutionになる、と言ってるが、なんでconvolutionなんだろう。
s自体トレーニングされる物なんだから、足し方の順番なんてどうでも良さそうだが…

まぁどうでもよいのでconvolutionでも良いはずではあるな。
lawのconvolutionは確率変数の和のlawになるので、アドレッシング確率変数の和になる、という事かもしれない。

3.3まででいいか、という事で3.4以降は読まないで本に戻る。

---

本に戻る。10.12のExplicit Memory。
p406とかは分かりやすく書いてあるが、論文読んでからじゃないと意味が分からないな。
Leaky Unitsもそうだったが、結構関連論文を自分で読む事前提にした解説だよなぁ。
back propagationを初めてこの本で学ぶ学生がこんなのついていけるとは思えない。
まぁ自分は学生じゃないんでいいけど。

ベクトルの理由、というのはなかなか面白い。なるほど。

content based addressingの理解は大分深まった。良い説明だ。
論文のアブスト写しただけ、という感じじゃないのが偉いね。

タスク用ネットワークとの関係も適度に雑に書かれてて良い。
この辺は詳細に踏み込むのでは無くてコンポーネントとしての役割とか意味を理解するのが大切だよな。

アドレッシングをsoftじゃなくstochsticにやるという話もあとでやるらしい。ちょっと楽しみね。

そしてGravesはひたすらLSTM関連の研究をずっと続けてる、というのは伝わってくる章だった(^_^;)  
彼のモチベーションは分かりやすいし、やってる事は面白そうね。

### このRNNの章は凄い良く書けてた！

10章を最後まで読んだので、10章の感想とか。

いや〜、この章は素晴らしいね。
9章のダメさと同じ本とは思えない。

これまで自分は何冊か別の本でRNNを勉強し、コードも書いてTensorflowのコードを読んだりもしたが、いまいち良く分かった気がしていなかった。

でもこの本読んでいくつか関連論文を読んだら、凄いいろいろ理解が深まって「分かった！」って気になった。

この章は本単体ではあまり良く無いと思うのだが、参照されている論文のチョイスとその補足としての本文が素晴らしい。
ちゃんと参照されてる事に意味があって、読んでいくとつなげたストーリーが理解出来るようになってるし、
元論文の要点が分かりにくい所はちゃんと本文で補足されてる。これが結構分かりやすい。

ただ流行りの論文並べただけの類書とは明らかに格が違う。
さすがBengio門下。
感動した。

ただ、本を読むだけだといまいちなので、本としての感想は結構人によって割れる気もする。
自分はRNN関連いまいち分って無くて苦労してたので、まさにこういう本を望んでたから評価はマックスです。

という事で10章は良かった。

# 11章、実践の時の方法論とか

この章はいまいちだな。
Googleで出来たやり方とか語られても、そうでない企業じゃ通じないよ、みたいなのが多すぎて。

ゴールを設定し、実験しながら改善していく、でDeep
 Learningベースの実サービスが作れれば苦労は無い。

いろいろな制約からたくさんの実現不能なサービスの中からどうやって物になりそうな物を探すか、って話が無いのは、Deep Learningという本の応用としてはダメだろう。いかにもDeep Learning時代以前の機械学習の話が多すぎる。

###  この本に欠けてる要素は何か？

11.2では、ゴールを決めたら、次にend-to-endシステムを一刻も早く作ろう、とある。

一方で自分の感覚だとそこまで行く前の段階でどう早く見切りをつけるか、というあたりが凄く重要で、そこにアートがあると思うんだよな。

こうして考えると、このアドバイスの問題点は、開始時点の11.1のゴールを決める時点で、一番難しい問題が既に解決されている所だと思う。

11.0の所で、手持ちのデータと環境で、やれそうな事を探す、っていう所があると思う。
そしてここは凄い難しくて、ノウハウもいっぱいあって、一番腕の差が出る所じゃないか。

出来る事と会社がやりたい事の接点を探す、というのは、普通の会社で実サービス作る時の、機械学習屋の一番重要な仕事と思う。
要求から始めても実現出来ない、出来る事から始めてもビジネスとしての価値が無い、この2つの問題をどう乗り越えて、さらに機械学習エンジニアのキャリアとして自分がやりたい事をやっていく、というのが在野の機械学習エンジニアという奴だと思う。

ただ、会社を選ぶのも大切で、
どこでやるか、によって出来る事はずっと変わるし、機械学習屋としてちゃんと仕事できるのは相当良い会社に限られるとは思う。

それをさらに推し進めて考えると、会社を選ぶ段階で、このへんのお膳立てが終わってる会社を選ぶ、というのも可能なのか？それはあるかもしれない。

自分がいくつか働いたデータ分析系の会社でそこまで行ってる所は無かったが。
たふんGoogleとかAmazonとかFBくらいしか無いんじゃないか？そんな会社。

### 機械学習屋としてのキャリアという視点

天下のGoodfellow先生とはレベルの違うところとして、我らデータ分析屋はもうちょっとキャリア的な事と仕事は結びつけて考える必要がある。

例えば、機械学習のサービスでは、まず機械学習を使わなくても出来ないか？と考えてみましょう、みたいなアドバイスしてる本とかある。この本の11.2にも書いてある。
これは本当にろくでも無いと思う。

というのは、リアリティが無い。全然分かってない。

「Deep Learningを使ったサービスをうちの会社でもやりたい」とチームを作ったとする。人を募集する。で、そこに自分がjoinしたとしよう。これは良くある始まり方だ。

でも、この後にサービス開発してるチームから「こんな事出来ませんか？」と相談された内容がたまたまDeep Learningで実現できて凄い利益になる、なんて、あり得ない。
そんな事は無い。断言出来る。

会社は予算をつけてDeep Learningのチームを立ち上げた。
でもこのチームは出来たばっかで、いつ取り壊されるかも分からない。
その短い滑走路の中で結果を出して示さないといけない。
これが多くのDeep Learningエンジニアの現実的な状況だろう。

そんな時にコンサルのスペシャリストでもなんでも無い人間がDeep Learningを使わないサービズの実現方法について考えるなんて、こんな馬鹿な事は無い。
そんなのサービス作ってるチームの方が得意に決まってる。

やらなきゃいけない事はそうじゃない。
サービス作る側のスペシャリストとデータ分析のスペシャリストが、お互いの限定された情報を持ち寄っていけそうな物を探すんだよ。
それを見つけるのは結構難しいが、それが見つけられなければDeep LearningチームはDeep Learningは出来ない。
やりたい事が偶然Deep Learningで実現出来る、なんてAndrew NgやGoodfellowでも無いとそんな事は無い。

まぁこの本はGoodfellowが書いた物だから仕方ないが…

当たり前だが、機械学習を使わなくても出来る事は世の中にたくさんある。
だが、そんな事を幾らやってもテータ分析チームの実績にはならない。

そして自分がデータ分析のキャリアを積み重ねていきたい、と思えば、それじゃダメだ。
限られた滑走路の中でマネージャーや他のチーム達に、自分のやりたい事の価値を認めさせないといけない。
最初は組織に経験は無く、データにも問題が多い。
そこでDeep Learningの価値を示して生き残らないといけない。

使わなくても済む方法を考えるのでは無く、使える仕事を探さなきゃいけない。
しかも必死に。

しかもDeep Learningはトレンドの移り変わりの激しい分野でもある。
この例に出てくるような2014年とかはこんな感じで良かったが、この本が出た2017年の現場は全然違ったと思う。
Deep Learningの本だというなら、Inception v3などのtransfer learningやEncoder-Decoderが普通に実戦投入されるようになった後の現場の話をしないと。

自分が先端の研究にrelevantな事をしていきたい、と思うなら、ただやれる事だけじゃ不十分で、自分がやっていきたい事で会社側にも利益になる事を探していかないといけない。

これは非常に難しい。だってやりたい事は普通、今後活発になりそうな分野だ。
だから既に定式化がおわって応用の道筋が固まってる分野じゃない。
そういうところでやれる事を探す、というのは、
ビジネスとか会社の立ち位置や性質とか人とか研究のトレンドとか自分の腕とか、
いろんな要素が絡んだ、非常に難しいバランスを取る必要のある事だ。

この本にはそうした典型的なDeep Learning屋が置かれている難しさが全て解決された所から正しいやり方を説く。
なんてくだらない章なんだ。

現在自分がやりたいと思っている事をどう企業の中でやっていくか、
というのは、Deep Learningエンジニアとしてはかなり重要な所だと思うんだよな。

キャリア的な物は企業や組織の要求に従ってるだけで勝手に良い方向に進んではくれないし、途中で方向転換したくなった時（今のDL界隈で方向転換が要らないのはむしろ少数派だろう）、組織のそれまでの経験と合わない事やりたくなる事だってあるだろう。

1. 自分はどの分野に今後力を入れていくかの選択
2. それをやっていくのに一番良い組織はどれか、を、その他の制約条件も加味した上で選択
3. 自分のやりたい事が出てきそうで実案件としてやれそうな物

というあたりは、みんないっつも考えて仕事やってるんじゃないかなぁ。
研究だけやってる、という人はまた違うと思うが。

### データにどのくらい問題があるかを理解するフェーズが無い

最初はデータに問題がある。
それはどの組織でもそうだ。
で、そのデータが悪いせいで出来ない事はたくさんある。

だが、その範囲で出来る事もある。

だから最初は、データ自身を理解する必要がある。

データを理解するプロセスは最初だけじゃなくてずっと続いていく類のものだし、クリーニングとか途中で必要になるのも日常的な話だけど、
最初からある程度「イケそう」じゃないと、どうにもならない。

end to endのシステムを作ってからやっぱこれじゃダメだ、と気づくのでは遅い。
それはたまに起きるのは避けられないが、そのリスクはなるべく減らさないといけない。

この辺の話がこの本には無い。

これでは、データ分析屋の周りが凄まじく高いエンジニアリングのレベルで、組織としてのデータ活用度がむちゃくちゃ高い所でしか生き残れない。
そういう所でだけデータ分析するのが正解なのかもしれないが。

---

などと大研究者をひがんでても仕方ないので本に戻ろう。

### 11.3 もっとデータ集める

もっと多くのデータが集められないがパフォーマンスが足りない、って状況はたくさんあると思うんだけどなぁ。

データ増やせなくてパフォーマンス足りない時は研究者の領域だから応用する奴は諦めろ、って書きぶりだが、
だからこそ何をやるかの選択が大事なんでしょ！とか思ってしまう。

ま、Goodfellowは研究者だ、という事なので、応用の方のアドバイスを聞く相手じゃないよな。

### 11.4 ハイパーパラメータ

この節も現場の大変さからは遠いぬるい内容だなぁ、と思ってたが、learning rateが低すぎると何故か高いtraining errorにとどまるが理由が良く分からない、という記述はいいね。

このtrainig errorが何故か下がらない、というのはありがちで、原因をいろいろ知っておくのは重要。
理由が良く分かってない、というのもいいね。
DLはそういうの結構あるよなぁ。

2018年としては、tarnsfer learnigの時の話がもうちょっとあっても良いと思うんだよね。
元のモデルのキャパシティは多いが最後のパラメータは少ない、みたいなの。
ここでのbias-varianceはまた違った検討事項が必要なので。
例えばレイヤーを追加するのと前のレイヤーをtrainableにする事の比較とかそういう話はちょっと聞きたい。

p419の、だいたいにおいて実務ではoptimizationは問題にならない、もpre-DL時代の話だよなぁ。

### 11.5 Debugging Strategies

ここは読んでて「その通り！」と思った。
勉強になるとは思わないが、こういう話ちゃんとしてる人はあんま居ないよねぇ。

とりあえ画像見たりとか音声聴いたりとかするの大切、ってのもいい話だ。

softmaxからconfidenceというのは分からない気がするが。
別にsoftmax値が0.5くらいだと自信が無い、0.9以上なら自信ある、という物じゃない。

street viewの数字認識、なんというか、こんなのGoogleくらいじゃないと無いだろ…と言いたくなる内容だなぁ。

### 11章読み終わり

全体的にはろくでも無い章だった。
やって見れば分かる事とか最近の良くある現場を反映してないとか。

だがまぁここはそういう章という気もするので、ブログ読むみたいな気持ちで軽く読み流すのが良かろう。

# 12章、実際の応用

この章は画像認識、音声認識、NLPといった分野でのDLの応用についての雑多な話が続く。
歴史的な事を振り返って当時を思い出し懐かしい気持ちになったりはするが、何かを学ぶ、という感じの章では無い。

という事で読むのが大変かったるい。

### 12.4 NLP

n-gramとかNeural Language Modelとかの話をしてる。
相変わらずこれで学ぶには分かりにくいが別段発展的な話題がある訳でも無い。

ただ、自分がこの章のどこかを深めていきたい、と思ったら、ここで紹介されている論文を読んで行く事から始める、というのはアリな気はしてきた。

n-gramとかNLMの話見てると、word2vecが出た時の事を思い出す。
自分はベクトル演算が出来て面白い、と言われても、そんなのおもちゃみたいな物じゃないか、と認識していた。
distributed representationという大きな文脈を全然理解してなかったなぁ、と当時の事を思い出す。

あれはいつの事だったかな？たぶんMSの某氏と飯食ってた時の事だから、2015年とか2016年とかだった気がするが。
不動産のレコメンドやってた気がするので2015年末から2016年の頭にかけてだな。

二年で結構いろいろ勉強も経験も積んだねぇ。

12.4.5はNeural Machine Translation。
ここも文章でだらだら説明されてて長い。

地味に内容がいろいろあるので飛ばし読みもし辛いが、新しい情報も無いか、あったとしたらこれだけじゃ分からない、という感じなので、時間掛かる割に得る物が無い。うーむ。

### 12章はいまいちだった

12章は、どのセクションも一冊の本になるような話ばかりで、とてもこの短さで何かが説明出来るような物ては無い。

でも地味に細かい話をするので知ってる事を読み飛ばす、というのが結構やりにくく、結局全部読むハメになった。
しかも意外と難しくて、疲れた。
そして読み終わった後に、勉強になった、という感じもしなかった。

飛ばさなかったのは何かの必要性を感じたからだとは思うので、要らない話とは思わないのだが…  
改善案は別段思いつかないが、無駄な時間を使わされたという印象の章だった。

# Part 2まで読み終わって

Part 2までで、Deep Learningの本としては一応体裁が整っていると思う。
ということでここまでで一旦本としての評価を下して良いでしょう。

といっても、[先日の9章まで読み終わった時点での感想](https://karino2.github.io/2018/06/04/218.html)からそんなに進んでないので差分だけ。

10章は素晴らしかった。満点をあげよう（偉そう）。
RNNをちゃんと学びたいならこの本だ。

11章はブログとか読むのと大差無いような中身の無い章だった。

12章も各トピックが短すぎてあまり存在価値の無い章だった。

ということで11, 12章はいまいちだったが、10章の素晴らしさはそれを補ってあまりあるので、本としての全体的な評価はこの三章で大分上がった。
10章は本当に良く書けてるね。 

ただ、10章はLSTMとかだけを読んでもダメで、10章を最初から全部読む必要がある。特にRNNはLeaky Unitsなどの関連論文まで含めてじっくり読んでいく必要がある。
目次見てそれっぽい所だけ見て判断しちゃダメです。
そんなに章構成はちゃんとしてないので、そういう読み方では誤解してしまう（私は誤解していた）

さらに10章は前提知識もかなりの水準を要求する。

ベイジアンネットワークとかHMMとか基本的な言語モデルとかの前提知識は居る。
CourseraのPGMのコースの1だけで十分かな？（2の途中まで居るかも。忘れた）
とにかくv-structureとかd-sepとかの知識が居るし、グラフィカルモデルから同時分布を書き下せる程度の理解はいる。

また、RNNとかLSTMとかの基本的な事はよその本で一回学んだ方が良いとは思う。
関連論文を読んでいく必要があるので、そのための背景知識というか、基本的な事は一通り知ってる状態で始める方が良い。

例えば深層学習による自然言語処理、あたりを先に読んでおく方が良い。

<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=qf_sp_asin_til&t=karino203-22&m=amazon&o=9&p=8&l=as1&IS1=1&detail=1&asins=4061529242&bc1=ffffff&lt1=_top&fc1=333333&lc1=0066c0&bg1=ffffff&f=ifr"> </iframe>

という事でかなりの前提知識を要求するが、それでもこの章はそれだけの価値がある。
元論文を薄めただけの解説ばかりのこのRNNという分野で、この本だけはちゃんと原典をより大きなコンテキストに置いて、追加の説明や解釈もたくさん足してある（というか追加の補足ばかりで原典に書いてある本体は、はしょり過ぎのような…）。

という事で9章のCNNがいまいちなのは残念だが、もう一つの目玉の応用である10章のRNNが素晴らしいので、この本は悪くない本だ、というのが自分の中での全体的な評価となった。
ただ序盤と10章は、なんかギャップある気がする。
明らかに対象読者違うでしょ…

こういう要求が高い本、自分は好きですよ。
わざわざGoodfellow大先生が書くのだから、むしろこうでないとね！

# Part 3 リサーチの話

Part3、どう読もうかなぁ。
とりあえず最初の所読むと最新の研究みたいなのが紹介されてそうなのだが…

その後の13章をちらっと見ると確率的なPCAをEM法で解く、みたいな話で、
明らかに後の章で使う為の内容になってる。
あんま独立してない？

ちらっと読んでいくと、EM法や変分ベイズやらMCMCとpartition  functionの近似やら、PRMLでやった話題が薄く紹介されてるだけに見えて、
あんまDeep Learning関係なさそうな章が続き、20章で唐突にDeep Learningの生成モデルをガチで話し始めるように見える。

うーん、これ、どういう事なんだろう？
13〜19章までは20章を読む為の下準備という事？
それともまだDeep Learningでの研究は無いが、Goodfellow先生的には今後この辺の研究のDeep Learning版が来る！と思ってるという事？

前者なら先頭から順番に読んでいきたいが、後者なら適当に飛ばしていっても良い気がする。
どっちかなぁ。
とりあえず最初の方は普通に読んで行って、途中までいったらまた考えるか。

# 13章 Linear Factor Model

この章、なんであるのかいまいち分からない。
別段deepでも無いし、何かの前振りなのだとしたらどの章の前振りか教えて欲しいなぁ。

13.4でSparse codingというのが出てきた。
何の話をしているか全然ついていけない。

PGMではLoopy BPがそもそもshanon limitに近いコーディングという話で出てきてたので、生成モデルとこの辺の話題が関連あるのは想像出来るが。

Goodfellow 2013dはieeeのなので見れなさそう。researchgateにはあるが見て良いのか良く分からんので諦める。

最後の所を見ると、どうもautoencoderの前振りっぽい。13.5の内容は理解出来るから先に進んでしまおう。

# 14章 Autoncoder

何のために何を解説してるのかさっぱり分からなかった13章とはうってかわって、14章は素晴らしいautoencoderの解説。

ただちょこちょこマルコフネットワーク知ってる前提の解説が入ってて、この本で初めて機械学習学ぶ人は意味分からんだろ…とか思ってしまう。

## 14.5  Denoising Autoencoders

autoencoderは一番基礎的なの知ってるくらいだったので、こういう話は全然知らなかった。

ただこれって凄い超解像度（いわゆるSISR）に似てる話だよなぁ。
概念的には超解像度はdenoiseなのだから同じで当然だが。

それにしても図14.3はComputation graphなのに、その一ページ前の図14.2がPGMなのは凄い分かりにくいよなぁ。

corruptionが条件付き確率なのは少し意外で最初パラパラ見てたら式14.14でわからなくなった。
へー、確率分布するんだ。
なんかHMMみたいね。

## Score matchingの原典を読む（Hyvarinen 2005）

14.5.1はestimating scoreという項。

そこで、ベクトル場を学習してるとみなせる、という話をしてるが良く分からない。
なかなか面白そうな話なので原典を読みたいな。
Hyvarinen 2005を紹介している。

[Estimation of Non-Normalized Statistical Models by Score Matching](http://www.jmlr.org/papers/v6/hyvarinen05a.html)

これか。
面白そうなのでちゃんと読もう。

### 導入

MRFだとpartition functionの推計が難しい事多い。MCMCとか良くやられるがいまいち。

俺たちはZまで含めたモデルの推計方法を思いついちまったぜ。

ニューラルネットじゃなくてPGMの話なのね。

### ノーテーション

![](https://i.imgur.com/cUZkQAD.jpg)

この位を見ながら読んでいけば、他のノーテーションは見れば分かるかな。

### 基本的なアイデア

シータを調整して元の分布を再現したい。

この時、 $$p$$ を $$p_x$$に近づけようとするとZが出てきてしまうが、 $$log p$$ のgradを $$log p_x$$ のgradに近づける、
と考えて置換積分と無限遠の境界条件を使うと、qの式のデータの分布による期待値でコスト関数が書けて、
最適なシータを選ぶのにZが要らない。

### score matchingという名前について

pdfのlogのgrad、つまり $$\nabla log p$$ とか $$\nabla log p_x$$の事をスコアと呼んでいる。

で、このスコアを近づけていく、つまりマッチングさせていく、というのが、score matchingという言葉の意味っぽい。

---

理解したので本に戻ろう。
学習してるvecor場は図14.4の緑矢印に相当する、と言っている。
ようするに一番近い点は垂線をおろした所なので、そことの差分ベクトルは線と直行する。gradもしそう。という事で向きは一致しそうなので定数倍を除いて一致するか。

で、RBMのトレーニングとの関係が語られている。
score matchingで学習したりするらしい。
そのほかautoencoderと関連が深そう。

その次にガウスcorruptionでのdenoising criterionは一般のencoder-decoderのパラメトライゼーションに使える、と言って図14.5が書いてあるがどういう意味だろう？

14.16を学習するのは、14.5の矢印を学習しているのに相当しそう。
で、これが任意の直線を表せる、と言っているのかな。

良く何を言いたいか分からないが重要性は良く分からないので原典は当たらなくて良いか。

### 14.6 manifoldの学習

うーむ、いかにも微分幾何の話題、という感じで自分には何が言いたいのかをちゃんと理解するのは出来そうに無い。

ただ低次元の多様体上に分布しているという仮定自体は馴染みが深いので、とりあえず良く分からないまま先に進む。

14.7のcontractive autoencoderも幾何学的な事は良く分からず。
ただ微分をペナルティにしておくとこういう感じのautoencoderが得られて名前をcontractive autoencoderと言う、という位の認識でとりあえずは進もう。

## 14章は良く書けていた！

読み終わったので感想とか。

13章が何を言いたい章だったのとは対照的に、14章は自分がこれまで見た中でもっともしっかりしたautoencoderの解説だった。

幾つか自分には理解出来なかった所もあるけれど、
全体的にはとても勉強になったし、また先の章の内容も知りたくなった。

Part 3は最近の研究の簡単なサーベイみたいな物、と聞いていたが、この章は普通に現代的なDeep Learningを理解する為の基礎となる章で、
むしろなんでPart2じゃないの？という内容だった。

何にせよ良く書けていて素晴らしいね。
autoencoderについての理解は大分深まった気がした。

# 15章 Rapresentation Learning

え？autoencoderってまさにrepresentation learningの話じゃなかったの？

という感じを受ける15章のタイトルだが、とりあえず読んでいきましょう。

### 15.1 layer wiseのpretraining

なんで機能するのか分かる程単純な話では無いのは明らかなdeepなネットワークのpretrainについて。

分からないながらもいろいろ調べられていて、これは知らない事も多いので勉強になった。
自分は良いlocal minimaのそばから始めるから良いのだと思ってたが、そういうもんでも無い、という説明を読んでやや説得された。regularizerの一種というのは良く分かってないが。

この手の物は効果を過大に宣伝しがちだが、ReLUとか導入後の世界で割と普通にSGDされがちな現状を踏まえたバランスの良い議論になってる。
この辺はこの業界の専門家らしい良い解説。

### 15.2 Transfer Learning

我らはTransfer learning世代なので、この辺の話はとても興味ある所。

全体的に雑談というかお話的な事が多いが、
なかなか良い。
普段やってる事を真面目に考える良いきっかけになる。

zero-shot learningとか凄いな。
テキストの説明を読んで画像を当てるとか。

### 15.3 Semi supervised learning

さらりとここでGANが出てくるのはカッコいいね。
生成モデルじゃなくてcausal factorのdisentangleとして説明するあたりが。

ここも良く書けてるね。

### 15.4 Distributed Representation

embeddingとかで良く出てくる言葉だがいまいち定義が良く分からんな、と思っていたdistributed representationについて、
似てるけど違う物の例が幾つか挙げられているのを見て大分どういう物か分かった。

## 15章は面白いが、自分の理解度は低そう

15章読み終わった。

いろいろと良く分かってない事について分かっている事を書いている部分が多いので、
読んでいてすっきり分かった、という感じにはならなかった。
各節の違いも良く分からず、なんか同じような事を繰り返し言ってるようにも感じられたり。

ただ、この分かりにくさは、ある程度は扱ってる題材に本質的な物な気がする。
そしてこの困難な内容に対して、これだけ良く書ける男も世界にそうは居まい、と思える内容だった。
この章もGoodfellow本が光り輝く章だったと思う。

全体的にお話的なレベルに留まっていて、良く分かった！という感じはしなかった。
ただお話がなかなか深みがあり、
いろいろと考えたり、心の中に普段やってるTransfer Learningの作業をどう整理して置くか、みたいな所のヒントにはなった。

全体的なregularizationという枠にいろいろな物を配置していく、
というのは、このGoodfellow本の一貫した姿勢だと思うし、
それがうまく行ってるのは何よりGoodfellowのキャリアが示している。

という事で自分にちゃんと消化出来たかは自信は無いが、勉強にはなった。良い章だった。

# 16章 Structured Probabilistic Model

なんかPGMみたいなタイトルだなぁ、と思って見たらPGMの話だった。 
Goodfellowは意外な程PGM好きね。
ニューラルネットの人はあまり使わない印象だったのだが。

知ってる人は16.7以外飛ばして良いよ、と言っているが、どうしたもんかなぁ。

### 16.2.1のベイジアンネットの入門はいまいち

自分はこの辺詳しいので読む必要は無いからいまいちでもいいのだけど、この説明は分かりにくいと思う。

同時分布を表すためのモデルだ、ということを強調しないと、その条件付き確率が何を表すのか分からんのだよなぁ。

自分が勉強会の時に話した内容が一番良い説明だと思うのだが、動画でもとれば良かったね。

### 16.2.4 Energy basedな話

Energy basedなDeep Learningはちょくちょく見るので、ちゃんとMRFとの関連で解説されているのは良いですね。
自分はこの辺興味あったがあんま詳しくなくてそのうちやろう、と思ってたので、ここの解説はちょうど良い内容だった。

### 16.7 Deep LearningにおけるStructured PM

この節は結構興味ある所だったので楽しく読める。

そうそう、なんでLoopy belief propagationじゃないのか、ってのはずっと気になってたんだよね。
もちろんそのまま適用するかはおいといて、似たようなアルゴリズムでいいんじゃないか、と思ってたが、そういうのはあまり見かけない。

distributed representationとhidden unitが多い所が違いだ、というのは、ふむ、そうか、という気になった。
ちゃんと理解したかは怪しいが、もともと雑談的な興味だったのでこのくらいの説明で割と満足。

## 16章、自分は好きだがほとんどの人には中途半端か

読み終わったので感想とか。

自分はPGM好きなので楽しく読んだが、客観的には帯に短し襷に長し、と言うところだろう。

知らない人がこれで学ぶのは無理だと思うが、一方で知ってる人が思い出すには細かい要らない話が多すぎるように思う。

例えばimmoralとかの話は思い出すだけなら要らないように見えるが、なんで入れたんだろ？後で使う？
Factor graphなんて登場しただけで一切使い方を語らない。BPしないと登場させた意味無いじゃん…とか思ってしまうが。

知らない人には、解説が簡潔過ぎて分かりにくいだけじゃなく、必要な物も無い。例えばプレートモデルとかが無い。
だからPGMの勉強には使えず、けれどその割には無駄に長い。

という訳で、PGMちゃんと勉強したいならCourseraのコースとかダフネの本とか他の本読もう。
この、他のオススメはそのうち独立したエントリに書くかな。

という事で内容的にはこれ要るのか？って内容なんだけど、自分はこの辺好きなので割と楽しく読んだ。

ちょくちょくDLという視点からの話が挟まり、それは結構興味深い意見なので、ふむふむなるほど、という気になる。

また、選ばれている内容がDL寄りなので、読んでいるとDL側の理解が深まる。

また最後のDLとの関係とか違いとかの話は自分的に前から疑問に思っていた所なので、著者の個人的見解をちゃんと述べてくれるのは読み物として良いね。

また、個人的にGoodfellowが意外とPGMに詳しくて重要視している、という事実を知れて、ちょっとPGMのDL界での立ち位置を考え直した方がいいかもしらん、と思った。思ったよりPGM的視点で考えた方がいいのかもしれん。

# 17章 モンテカルロ法

目次ちらっと見て、あぁMCMCの話ね、と思って読んだら、意外とその手前の話が多くて、しかもちゃんとDLの視点で書かれていてなかなか良い。

なんというか、Part 3はこういう感じを皆期待してると思うのだよな。これまでの章は違ったが。

mixing timeってのが出てくるが、バーンインと何が違うの？と思って以前読んだMCMCの教科書ひっぱり出したが書いてない。
一つのサンプルから次のサンプルまでの遷移の回数だっけ？
まぁいいか。

それにしても「バーンイン時間 mixing MCMC」でググったらmixingとMCMCを取り除いた候補を一番上に出すGoogle検索は無能では無いか？

### 17.5 mixingが難しい、という話

Deep Learningだとmode間の移動が難しいというMCMCの問題の被害をもろに被る、という話がある。

ここを詳しく扱うのはDLの本っぽくて良いね。
あまり良い結論は無さそうだけど、Energy  basedなモデルに温度の要素を入れるのが将来性がありそう、というのが現在の状況と理解した。

生成モデルについてこれだけ詳しく説明する本ってあまり無いけれど、DLというコンテキストではここが最重要な訳だよね。

# 18章、Partition Function

18章はMRFでのpartition functitionの話をするっぽいので知ってるような事かな、と思って読んでたが、開幕から全然知らない内容で驚いた。

この対数尤度の最大化を2つに分けるって話、自分は初めて見た気がする。
そこからMCMCを近似しよう、というのは分かりやすいストーリーだ。

一応Noise-Contrastive Estimationとかは昔word2vecとかtopicモデルやった時に勉強はしていたのだが、この章のようにちゃんと基礎の所から考えて理解した、という訳では無かった。

## 18.2 Contrastive DivergenceとSML

バーンインまでやり直すよりは実データからやろう、というのがCD法らしい。これは理屈も問題点も分かりやすい。
2009年くらいまでの参考文献が多いが、当時流行ってたのかなぁ。
自分が見た事無いので最近はあんま流行ってないのだと思うが。

で、前回のステップの値から始めるのをstochastic maximum likelihoodと呼ぶらしい。これもまぁすぐ思いつく事だよなぁ。
2010年あたりまでは自分でも出来そうな研究が多いねぇ。

この辺の時代だと、Hinton先生がめちゃくちゃいろいろやってるなぁ。

### 18.3 Pseudolikelihood

この節は全然ついていけなかった。
何の話をしているかもよく分からない。
この本、知らない分野だとこうなるよねぇ。

18.19式から18.20式になった時、
計算量がどう減ってるのかよく分からない。

Besag, 1975を読め、という事だと思うが、いまいちこの辺のDLでの使いみちが分かってないので追う気も起こらないなぁ。

とりあえずこれを使う所まで進み、その内容が重要そうだったらちゃんと原典を読もう。

### 18.4 Score matchingとか

score matchingに関しては14.5で原典を読んだので、何の話をしているかは分かる。
ratio matchingはついていけてないが。

でも18.4だけだとやはりどう使うかが良く分からないなぁ。
後半で解説すると言ってたから期待してたのだが、さらに先で使い方を教えてくれるのかねぇ。

そう考えると先に20章読む方がモチベーション的には分かりやすいのか？

とりあえずこのまま進む。

### 18.6 NCE

NCEはどういう物かも、word2vecとかで使ったのでどこで使うかもわかるので、なかなか興味深く解説を読んだ。

特にこのうまく行かない時の話は、自然とGANなどとの関係が想起されて良い。

self-contrastive estimationとか完全にGANやん、とか思うが、これがGoodfellow 2014か〜、とか思う。

### この本は、既に知ってる事をコンテキストに置くための本

そうなんだよなぁ、この本は様々な研究を紹介する本「では無くて」、既にメジャーな奴について経験も知識もある程度ある時に、それを全体的なコンテキストに置くための本なんだよなぁ。

それってのは凄い本だとは思うのだけど、こんな幅広い話題について既に知ってる、という人はほとんど居ないと思うんだよねぇ。すくなくとも自分は知らない事も結構あった。

どう使われるのかとか説明しておいてくれればもうちょっと知らないトピックからも得る物があるのだが、この本はそこは既に知ってる、という前提で書かれてるんだよねぇ。

だからNCEとか既に知っててどう使われるかも分かってる節は良く書けてるように見える。
逆にpseudolikelihoodやscore matchingは「で、結局これは何に使うの？」という印象になってしまう。

### 18.7.1 焼きなまし法

名前は聞いた事あるが勉強するのはたぶん初めての焼きなまし法。

と思ったが式18.47は見覚えがあるな、とPRMLを見直したらちょろっとだけ出ていた。
ただ名前は出てなかった。

18.52がどこから出てきたのか良く分からなくなったのでimportance samplingを読み直す。
こういう時はPRMLの方がいいな。

<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=qf_sp_asin_til&t=karino203-22&m=amazon&o=9&p=8&l=as1&IS1=1&detail=1&asins=0387310738&bc1=ffffff&lt1=_top&fc1=333333&lc1=0066c0&bg1=ffffff&f=ifr"> </iframe>

p532の 11.1.4 importance samplingを見直すと、式11.19の所でimportance weightというのが出ているな。

importance samplingは、もともとpでの期待値を、qでの期待値に置き換えて近似する、という手法だ。

pからサンプルしてpfを求めて足し合わせれば期待値になる訳だが、これをqからサンプルしてpf/qを足し合わせる。
この時、サンプルした各点に対して、その点の場というか重みみたいなのがある、と思って、fの重み付き和として考える訳だな。

さて、Goodfellow本に戻ろう。
18.52式は18.48式のweightになってるという事だろうな。見てみよう。

18.48を順番にimportance samplingしていく事を考える。
まず、18.44と同じような事をする訳だよな。

![](https://i.imgur.com/WSBYByX.jpg)

こんな感じで、Zの比をunnormalizeなpの比の和にする訳だ。

で、18.48式を、

![](https://i.imgur.com/CCqxaBv.jpg)

端から順番にサンプリングしていく事を考えると、

![](https://i.imgur.com/7IYTemn.jpg)

こういう感じか。ちょっとごちゃごちゃしてるが、各シグマは一つ前の分布、つまり分母の方の分布からサンプリングする。

で、これをバラバラにやって平均をとって掛ける代わりに、それぞれの分布から一回サンプルをとってその値を入れて、次にまたサンプリングしてその値を入れて、、、と求めた物を平均する、というのが18.53だな。

で、このサンプリングを遷移行列使うというのがポイントなんだろうが、そこは意味的にはどうでも良い。

で、wはweightだと言うが、importance samplingのfに相当する物が無いので、いまいちweight感は無いなぁ。
だが、順番にサンプリングしていった時に、それら全ての同時分布のweightっぽい物になってるのはそんな気がするので、納得は出来た。

お、その後のp619は私の解釈が正しいかをいろいろ説明している感じの内容だな。すばら。

全部ちゃんとは追ってないが、18.54のように同時分布を定義するとTがいっぱい出て来て、18.60のようなproposalによるimportance samplingすると打ち消して消える、という感じか。

感覚的にも同時分布にしたらqみたいな分布のimportance  samplingになるか、または漸近的に近づく気がするので納得は出来た。

この手法が良く使われるのはRBMの論文で凄い流行った奴で使われてたからで手法が優れてるからって訳じゃない、という注釈がちょっと面白い。ほんまかいな。

## 18章は自分には半分くらいしか分からなかった

ここまでこの本を読み進めてきた印象としては、この本は扱ってるトピックとDLの関係をあまり話さない。
だが関係はあって、その分野知ってる人からすると書いてある事はなかなかためになる、みたいのが多い。

で、18章の半分くらいは自分が知らないから何について話しているのか分からないなぁ、という印象だった。
このpartition functionの推計の話ってPRMLでもやったんだけど、実際にコード書く時に遭遇した事ほとんど無いので、
どういう時に必要になるのか良く分かってないんですよねぇ。

そういう訳で、NCEのような良く出てくる奴はなかなか興味深い解説だと思ったが、そのほかの奴、例えばpseudolikelihoodとかは、何の話をしてるのか全然分からんかった。
どういう時に必要になるのか良く分からない物の近似の話をずっとやってる、という感じでモチベーション上がらなかった。

一応MRFとかは昔それなりに時間かけてやったので、全く分からない訳でも無いあたりが、自身の無理解を理解させるというか。

そのうち必要性を理解したら原典追ったりして読み直したい。

あと、何故かしらないが18章は凄い辛かった。
意外と真剣に読まないと頭に入ってこない割に、別に知りたいという気がしない話が多くて、ここまでで一番辛い章だった。

これ、みんな乗り越えた？飛ばした？その辺の雑談とかしたい。

# 19章 変分ベイズの話

19.1は普通にELBOとかの話してるので、この章はタイトルから想像できるように変分ベイズの話らしい。

19.2はEM法の話。さすがにこの辺は分からない事無いな。
それにしてもcompleted datasetって何の説明も無く使ってるのはちょっと酷い。

## 19.4 実際の計算

何故か19.4.1から具体的な例の計算が始まる。
意図は分からんが、いい機会なので追ってみるか。

まず19.19でhの分布が、そして19.20でhの条件付きでvの分布が定義されている。

で、最尤推定でパラメータを決める為に、まず観測値の分布を求める。
それはhで同時分布をマージナライズする訳だが、同時分布は積の法則で条件付き確率で表して和を取る事になる。

こうして得られる尤度をパラメータのbでまず微分している。
bの他にWとかも決めないといけない気がするが、とりあえずbからなのかな。

で、bで微分すると19.26のようになる、と言っている。
$$p(v | h)$$はbの偏微分の影響は無いのかしら？hを通してありそうな気もするが…

まぁ細かい話はいいか。
で、19.26の式はlogの偏微分の$$p(v | h)$$による期待値と解釈出来る、と言ってる。
だが期待値を得る為のサンプリングは出来そうも無い。

そこで変分近似を入れる。
まず期待値を取る分布をqとして、qは19.28の形でfactorizeされるとする。

ここでちょっと立ち止まって何をやったのか考えてみる。

サンプリングする対象を見直すとhだ。
だからhをサンプリングして期待値を近似したい訳だ。
で、hは0と1のどちらかの値をとる何かだった。
それは19.19で表される。

これはfactorizeされてないのだろうか？と考える時に、図19.2のグラフィカルモデルの出番となる。

だがそんなの無くても式19.20を睨むとなんとなくは分かる。
線形和としてvに入るので、vがobserveされたとすると、片方をいじると他へも影響は出るだろうな。
これが図19.2の左の図で、いわゆるv-structureでのobservationになるから依存が復活するケースと解釈出来る、という話の直感的な解釈。

さて、これらはfactorizeされてなさそうだから、19.28はこの相関の所が落とされてしまっている。
逆に相関を落とした結果、観測値に対応した単なるベルヌーイ分布の積に出来る訳だ。

本に戻ろう。
ベルヌーイ分布の1の確率をhのハットで置く。そしてELBOにこの式を代入して19.30から19.36まで計算してる。
あら、bでの偏微分はどうした？とりあえず読んで見るか。

ぱっと見19.32から19.33の間が見るだけでは良く分からないので自分でも計算してみよう。
19.34は19.32の真ん中の項っぽいな。
という事でここ以外を考えてみよう。

![](https://i.imgur.com/zi2z0Ec.jpg)

で、期待値をとる為には、hが1の時と0の時の大かっこの中の値を計算し、その重み付き和をとればいいのかな。

![](https://i.imgur.com/zVhihuM.jpg)

あとはこの2つの重み付き和を取れば19.33になりそう。

19.36はlogの計算をして、単にhにhハットを入れれば良さそうね。

という事でELBOが出たので、普通ならあとはEM法でhハットとbとWを求めれば良い、という事になるが、それだとhがxの数に応じた分だけ保持しておく必要があるからGPUに優しくないのと、vからhハットをリアルタイムで計算したい事がある事から、もっと早い近似を使うとの事。
へー。

で、一次の微分がゼロ、でギブスサンプリングみたく順番に更新していくという方法が紹介されている。

ここまでの話の仮定を確認しよう。
19.19と19.20みたいなモデルを考えている。
これはsparse codingのモデルで、hにcodingする、という物だ。

で、これを最適化するのに期待値を取る所でqによる期待値に置き換える近似が入り、このqは19.28でfactorizeされる関数形だけを探索空間とする。

この最適化はsparse coding一般で、factorizeだけを仮定して計算出来ている、という事になる。

話を戻そう。
hハットはELBOの偏微分をゼロと置いて解析的に計算してみている。
これが19.44。

この式は、右辺にi以外のhハットが入っているが、これを適当な初期値から初めて順繰りに更新していくらしい。

その次の説明で、これはRNNの式になってる、みたいな話がある。
なかなか興味深いが、どの辺がRNNなのだろう？

式19.44を見ると、まず入力はvでどのhidden unitにも同じ物が入ってる。
なのであんまRNNっぽく見えない。
さらにhjは全部必要なので、なんかattentionみたいだよなぁ。

一方でRNNの本質を、自身へのフィードバックがある、と考えると、hiハットがhiハットの入力に入ればRNNという気もする。

一期前のhiハットは、そのhjハットを通じてhiハットの入力に入っている。
そう考えるとこれは凄く非線形な変換が間に挟まったRNN、と見る事が出来る気がしてきた。

で、その後にhjと向きが揃ってると、19.44式で入力を打ち消す、と言っている。
これはある入力を説明する変数としての地位を奪い合うようなもの、とのこと。ふむ。

explaining awayはなんかちょろっとしか解説してなかった気がするがバンバン出てくるよなぁ。ベイジアンネットワーク力じゅうやう。
で、factorizeを仮定してるからexplaining awayがうまくされない、という話から、図の3.6の状況だ、との説明が。
3章！まじか！と見直すと、KLダイバージェンスの非対称性の話。
ちゃんと後で伏線（？）回収するのは偉い。

その後の平均場的な説明も良いね。
19.4は良く書けてるな。

そのあとdampingとかの話があるが、これは我らがKollerの本が参照されてるね。LoopyBPとかの話かね。まぁ良かろう。

### 19.4.2 変分計算

fの微分が含まれない形の変分計算の式が載ってるが、いまいちイメージがつかめない。
手で計算するか…

![](https://i.imgur.com/dzgP3kN.jpg)

あれ？微分が含まれてない場合、こっからどうするんだ？

と汎関数微分でググってたら、[汎関数微分](http://eman-physics.net/analytic/functional.html)でこの辺が解説されてた。

なるほど、これが定義か。
なんかRadon-Nikodym微分っぽいが、いつか両者の関係を分かる日が来るのだろうか…

とりあえず式をあてはめるとこうかな。

![](https://i.imgur.com/wdFLh46.jpg)

とりあえず19.46式は導出出来た。
その後の直感的な説明を読んでおこう。

なんか無限次元のベクトルみたいなもんで、有限次元の和を微分すると和が消えるじゃん？みたいな説明があるが、ちょっと消化しきれないので少し考える。

19.46の右辺のxとは何か？というと、左辺のデルタの所のxだよな。
積分の所と区別するためにx0と改名しよう。

![](https://i.imgur.com/OJvVfop.jpg)

この汎関数微分の記号の意味は、x0の周りの関数だけをちょっとずらした時の変化量、という意味か。

xの範囲をどれだけ動かすかとか真剣に考えると全微分とかでやらなきゃいけなさそうだが、気分的には微小範囲なら積分はそこの点の値にデルタx掛けるだけなので、そのデルタxで割れば中身だけが残るのだろうな。

そんなふうに考えると離散化した19.47の式とほぼ同じ事、という気がする。
xを離散化した時に、x0以外の項は残らない、という事か。
汎関数微分周辺をちゃんと勉強しなきゃいけない、という気分は高まったが、
なんとなくは納得したので先に進もう。

次にentropy最大の分布が、関数形を仮定しなくてもガウシアンになる、という話をしている。
おぉ、すげー。

なんかこの計算、これまでの人生で何度か見てきた気がするが、今初めて全部理解した気になった。すげーな。

汎関数微分、何度もこれまでの人生で出てきてたぶん計算も何度かやってるが、年々何をやってるのかの理解度が高まって感動する。逆に以前は何も分からずに計算してたんだよなぁ。今回19.52で積分記号が消える理由を初めて正確に理解出来た。

この本、他の所の解説はこういう感じじゃないのにここだけこういうのがあるのは、きっとGoodfellowも汎関数微分に苦労してこういう解説つけたんじゃないかね。だとしたら自分はまさにその対象読者だった訳だな。

### 19.4.3 連続なlatent variableでの変分推定

突然、平均場近似なら導出は知らなくてもいいんだよ、19.56になるから、とか言い始める。まじかよ！Goodfellow！

だが我々はPRMLでこの辺全部やったので、PRMLを見直すのだった。10.1やね。
ELBOにfactorizeの仮定を入れて、積の積分をj番目とそれ以外に分けて書く。
するとそれ以外の部分は同時分布のlogの平均場近似した期待値となる（10.7式）。

で、j以外を固定してELBOを最大化すると、これが偶然（？）同時分布のlogの平均場での期待値とqjのKLダイバージェンスにマイナスをつけた物となるので、最大化はこの同時分布のlogの平均場の期待値と一致した時、となる。

このlogをとる為にexpをつけるとGoodfellow本の19.56となる。
おー、全部分かるぜ。頑張って昔勉強した甲斐があった。

でGoodfellow本に戻ると、ガウシアンなケースでの変分推定の計算例が載ってる。
これは別段分からない事も無し。
簡単で良いね。

で、実際のDLでの例はGoodfellow 2013dを見ろ、と書いてある。
で見てみると、これは前探したらieeeのでダウンロード出来なかった奴かー。
そのうち図書館とかであったら読んでみたいなぁ。
購入するとnon-memberは33ドルとか。やや高い。

## 19章はとても勉強になった！

読み終わった〜！この章もなかなかきつかった。

ただ自分にはとても良いPRMLの復習になった。
なんか他の章より親切に書かれてたような。

EM法とか変分ベイズをどこかでまじめにやった人が読む内容という気はした。
全体的にPRMLの方が親切で分かりやすいと思う。

ただ例があんまり複雑な所まで行かないので、基礎だけを固めるのに良かった。
コンパクトにEM法と変分推定がまとまってて、それなりにちゃんと理解出来る記述がある章だった。
他の章は「これだけの説明じゃ知らない人はわかんないよ(´・ω・｀)」という感じだが、19章はそれらよりは詳しくて、
これで勉強する事も可能とは思うし、
復習に使うなら十分な内容だった。

あと題材がsparse codingとかなのでやる気が出るね。

そしてようやく次は20章だ！ここまで良く頑張ったよ、ほんと。

# 20章、Deepな生成モデル

やっと本題の20章まで来た！長かった…

## 20.3 Deep Belief Networks

これは初めて勉強する。

中身が凄いPGMで驚く。最初はこんな感じだったのかぁ。
自分はかつて世の中はこういう方向に行くんじゃないか、と思ってたのだが、一度こんな所まで来てたのね。

では何故これが流行らなくなったのだろう？気になる。

### 式の解釈

20.17はMRFで、expの中がenergy functionのいわゆるenergyモデルだな。
これがhの同時確率になる所がいわゆるcomputation graphとの違いだ。

で、次の層からは1かどうかを予想するロジスティック回帰が並んでいる訳だな。これが20.18か。

こうしてみると、各ノードの結果を確率と解釈するか以外には単なるニューラルネットと大した違いが無く見えるな。

### サンプリングが面白い

サンプリングが簡単なのが面白い。
単にMRFからギブスサンプリングして、
そこからはancestral samplingしてくだけで良い。簡単。凄い！

これ、なかなかいいんじゃね？と11年前のモデルに感銘を受けたりする。

### inferenceが出来ない！

こんなモデルがちゃんとトレーニング出来るなら生成モデルはこれでいいやん、とか思った所、inferenceが出来ない、という話が。

なるほど、Observationが入るとintractableになってしまうのか。
あれ？それじゃどうやってトレーニングするんだろう？

まず観測値の層と隣の層をRBMとしてトレーニングする、と言ってる。
えーと、hの条件付き確率の式と観測データがある時に、hはどう学習されるんだっけ？

20.2.1を見直すと、同時分布がわかってるからどっち向きの条件付き確率も計算出来て、それはvによるロジスティック回帰になるのかな？（20.14）

なんかこれではcontrastive divergenceが要らない気がするが…
とりあえず先に進もう。

こうしてWとc（DBNの式だとb）が学習される、と。で、h自体は降ってくる値になる訳だな。

で、次の層のWをどう学習するかというとh1の分布が分かったので、ベイズルールを使ってh2の確率は出せるのかな。

20.18式が以下で、

![](https://i.imgur.com/ClvtZHg.jpg)

これにベイズルールを適用すると、

![](https://i.imgur.com/rLkkauo.jpg)

h2のpriorってなんなのか良く分からないが、とりあえずW2とb1の学習には影響無いだろう（たぶん）。

すると、各vに対してh1をサンプルして、、、ってh2はどうするんだ、という話になるな。これじゃだめか。

本にはRBMだと書いてあるが、これ、定義ではMRFじゃなくてBayesian netの層だよなぁ。
そもそもさっき、vとその隣の層をMRFとして計算してたが、良く考えたらそこもBayesian netだから間違ってる気がしてきた。

Bayesian netである以上、同時分布はグラフから構築出来るはずだよな。
inter layerのコネクションが無い、という事は、

![](https://i.imgur.com/tgshUWq.jpg)

こうかな？

うーん、あんま変わらないなぁ。これをどう学習するんだろ？

良く分からないので昔読んだ以下の本のDBNの所を読み直すと、

<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=qf_sp_asin_til&t=karino203-22&m=amazon&o=9&p=8&l=as1&IS1=1&detail=1&asins=B01B768QJW&bc1=ffffff&lt1=_top&fc1=333333&lc1=0066c0&bg1=ffffff&f=ifr"> </iframe>

2.9.1の所（p74）で、「事前学習の時には有向グラフである事を一旦忘れ、無向グラフとして学習し、そのパラメータを有向グラフの重みとして使う」というような事（一部改変）が書いてある！
まじか！

そう言ってくれないと分かる訳無いじゃん！Goodfellow先生！

で、なんでそんな事をして良いのか、というと、
この学習が下界を上昇させるアルゴリズムな事が証明出来るらしい。
これも深層学習本のp75から2.9.2として証明が書いてある。
こちらの方がこの辺は難度が高いな。

証明は全部追うのはげんなりする内容だが、ようするにDBNを地道にマージナライズしていくと下の層では対数尤度がそのまま上昇する事が、隠れ層ではRBMの規定する分布とのクロスエントロピーみたいなのになり、下界が抑えられるっぽい。

計算すれば出来そうでそうなってる、というだけっぽいので、このくらいの理解でサボって先に進もう。

### RBMの学習を深層学習本の方で見直す

せっかくなのでBM周辺の学習もこの本で復習しておこう。
メジャーなモデルの具体的な話はこちらの本が大分具体的かつ詳細に書いてあるので。

で、BMはまず観測値以外の隠れ変数をひたすらマージナライズして対数尤度を出し、パラメータでそれを最大化する、というのが基本的な流れの模様（p48の2.25式）。

で、この式がマージナライズの都合で観測変数の期待値みたいなのになる訳か。
（式2.17.とか）。
なんかこれ、昔どっかでやった記憶があるな。結構たいへんだった気がするが、、、とPRMLの目次を見直したが見つからず。まぁいいや。

で、この期待値計算が確率変数の組み合わせの数だけ計算するのでintractableなのか。

---

ではGoodfellow本に戻ろう。
DBNの学習は、二層ごとのBMとして学習していく。

これは条件付き確率が分かるので、ベイズルールからunnormalizedな同時分布がわかり、これを最大化するようにパラメータを選んでいけば良い。
この時は18.1でやった話を適用する訳だな。

一応復習しておこう。
まず対数尤度のパラメータ微分は18.4の形で書けて、これが分かればxをサンプリングしてgrad ascentすれば良い。

でも18.4の第二項はRBMとかでは分からないので、近似する、という話になってる。

20.2.2ではRBMはpチルダvが簡単に計算出来る、とあるが、それはどうやるのか？
えーと、同時分布が20.4で与えられてるのだから、これをhについてマージナライズしてやれば良い。hは0か1なのでマージナライズも簡単か。

話を18.4に戻す。第一項は結構面倒だが解析的に計算出来そう。

で、第二項は18.15式で近似出来る、と。
これはいろいろやり方があるが、観測値から始めてMCMC でサンプリングした平均を期待値とする訳だな。観測値から始めるのをCD法と呼ぶらしい。

で、これを使って対数尤度を最大化するシータを求める訳だ。20.2.2に戻るとWとかbをこれで求める訳だな。

よし、RBMのイメージがつかめたので、DBNに戻ろう。式20.21の周辺。

p2というのは二段目のRBMだな。
で、この観測値に相当する物はh1になる訳だ。
このh1は観測値を定めるとRBM1からサンプリング出来るのでサンプリングして、それを最尤推定する訳か。

ややこしいが、h1が確率分布になってるので一回サンプリングを挟む必要がある。（MAP値使うとかも出来そうだが）。

で、これを繰り返して得られるパラメータをDBNに使う。
理解は出来た。

### DBNのトレーニング雑感

まずRBMのパラメータを全然別のDBNに使う、というのは変な事してるな、という印象がある。
理論的には下界を引き上げるトレーニングになってるから、DBNのパラメータ更新としても近似になると言えそうだが。

また、hをサンプリングしなきゃいけないのが辛いな。
観測値とhが一対一対応しないから。
これはRNNの学習とかとは違う所ね。
全体的にぼやけそうな気がする。

### DBNを推論に使う話

DBNが学習出来たら、データを生成するhの各ユニットが1になる確率が計算出来る。
このhを用いてclassificationを新たにトレーニングするらしい。
これは現代のfine tuneと同じような物だな。

### DBN読み終わり

地味にBMをあまり理解してなかった事などが露呈して無駄に時間を食ってしまった。

DBNって他の本でも見かけたが、「昔そういうのがあったのね、でももう使わないからどうでもいいや」という態度であまり真面目に読んでなかったのだが、
今回真面目に式を見ていったらなかなか面白かった。
やはり実際に計算したい物があると、18章とか真面目に読む気も増す。

DBNは非常に汎用的で学習可能で、しかもいかにもPGMなのが驚いた。こんなに確率モデルしてるとは。

ただ、スコアは悪そうな気がする。
間にhのサンプリングが入るのがなぁ。
汎化性能は高そうだが。

夢はあるがやはり過去のモデルやね。

## 20.4 Deep BM

お次はDeep BM。昔見た時はやっぱりこれも「ふーん、昔使われてたのね。でも今はいらないもんねー」という気分であまり真面目に読まなかったのだが、
今回は結構モチベーション高く読めている。

まず自分がDL界隈の現代的なモデルでの作業を結構経験したので、そういう現代的な事は「もう知ってる」と思うようになって、少し古い話を聞く気になった事。

そしてGANが流行ったおかげで生成モデル自体の使いみちをいろいろ知り、またそれらの基礎としてこの辺の話題の関心が上がった、という事もある。

また、Googfellow御大が載せてるのだから今でも要るんだろう、という気分にもなってる。

とにかく前よりも真面目にやる気が湧いてるので真面目に読んでいきたい。

### 基本的な構造

さて、Deep BMと言えばMarkov Random Fieldの亜種だ。

ネットワークとしては隣の層としか接続が無く、隣の層とはFully connected。

で、これはMRFなので計算グラフじゃなくて、同時確率をモデリングしてる訳だ。
energyモデルとなってる。

特徴としては偶数番目のレイヤーは、奇数番目のレイヤーとしかつながらないので、図20.3のようにbipartieになってる。

つまり相手側をgivenとすると全てConditionally independentになる。
だから条件付き確率の積で同時分布が書ける。
20.26、20.27、20.28がその表現。

hidden unitはバイナリ、つまりゼロイチの値。
だから分布はベルヌーイ分布で良い。

### 20.4.2 平均場近似

ちょっと読むだけでは20.33が良く分からなかったので、自分でも計算する事にする。かったるい〜（T_T）

さて、DBMは偶数レイヤと奇数レイヤは条件付き独立の関係がある訳だが、
さらに近似を入れて、観測値をgivenとした時のhiddenレイヤ同士も条件付き独立と近似して計算する、という話。

factorizeされてる分布をQとおいて、これを元の分布に出来るだけ近づける。
とりあえず2値なのでfactorizeを仮定すれば20.32の形で書ける。あとはhハットをfittingすれば良い。

本には19.56を使えば良い、と書いてあって結果だけ載ってる。
とりあえず19.56が何だったのかを復習しよう。

19.56式は、19.4.3のhiddenが連続の時の変分推定の話。あれ？離散値でいいんじゃないの？と19.4.1を読みなおすと、
やっぱり離散値で良さそうな気がする。
うーん、かったるいが勉強の為やってみるか。

まず式19.6の符号を中に入れた物から始めよう。

![](https://i.imgur.com/vVsjuNm.jpg)

こいつのhの極値を求める、というのが19.18で紹介されてるやり方だな。

同時分布は20.24で、qの方は20.32で表されているので、理論上はこいつらを全部突っ込んでhハットで微分すると何かが分かるはずだが…
ちょっとゴツいな。

とりあえず一通り書き出そう。

![](https://i.imgur.com/tyy1HSS.jpg)

これだとh3とW3があるが、20.4.2ではこれらは出てきてないな。何故だろう？

ようするに20.28式でなんでh3が要らないのか、という話かな。
まず図20.3のMRFからfactorの形で同時分布を書いて、マージナライズしていこう。

![](https://i.imgur.com/c9BdpPr.jpg)

なるほど、h3とW3は分母と分子の両方に入るからキャンセルされるんだな。

この辺のfactor計算はしばらくやってるとMRF見ただけで出来るようになるんだが、久しぶりなのでなかなかそうは行かない。
図20.3を見てすぐクリークが分からないとねぇ。

仕方ないから、分からない所は全部同時分布に戻って計算していこう。
めんどくさいが仕方ない。
この辺は心を無にして手を動かす、とPGMのコースで学んだ。

さて、どこから手をつけたもんか。まずELBOのうち、h3のマージナライズを計算した物を考えよう。

![](https://i.imgur.com/mZJhLM9.jpg)

で、qの形は昨日PRMLで計算したな。
jだけ残すとpチルダのlogの、j以外のqによる期待値とのKLダイバージェンスになるので、qをpチルダの期待値とするのが最大になる、という話だった。

それが式19.56だな。
これでqを置いて、hハットで微分するのかな？

いや、待てよ？
そんな必要無いんじゃないかな？
そもそもhは全部二値で、ゼロの時はエネルギーの中の項は全部消えるよな。

という事はこのqによる期待値は、単純にhハットを代入したものになるんじゃない？
で、Qの方はベルヌーイ分布（20.32）のlogの期待値か。
これって幾つだ？

![](https://i.imgur.com/3unUw4s.jpg)

こんな感じか。

という事は期待値が普通に計算出来るんだな。
それならh3で積分して無い方が良かったな。戻そう。

以上をふまえると、期待値を計算してやるとELBOは、

![](https://i.imgur.com/MVXoY94.jpg)

となるか。あってるか自信無くなってきたが(^_^;)

で、これをhハットで微分してイコール0と置くと、fixed point equationが得られる、という事だよな。
やってみよう。

![](https://i.imgur.com/7xaQpoK.jpg)

これを整理すれば20.33になりそう。
やる気なく確認したらなりそうだった。
以下そのメモ。

![](https://i.imgur.com/FVIrlZ3.jpg)

よし、理屈はあってる事が分かった。
やはり19.56なんて使わずに、ベルヌーイ分布の期待値を手計算すれば良い。

h2の方はぱっと見h3とW3の項が残る気がするが、何故20.34にはそれが無いのか？

なんか20.4.2を真面目に読み直すと、ここからはhidden layerが2つの時を考えているんじゃないか？20.4.1までは3つっぽいが。

おー、そうっぽいな。これは分かりにくい！
でもここまでの計算から、h3が無ければ20.4.2の記述になるのは容易に想像出来るからまぁいいか。

### 20.4.3 パラメータの学習

hは先程出したfixed pointの式から出る訳だが、Wの学習はまだやってないので、どうにかして学習する必要がある。

というかさっきのELBOにはlog Zの項を書き忘れてたな。どうせ微分して消えるからさっきの計算では些細な話だが。

ただWを学習する時には必要になる。
で、log Zのgradとかは18章でやった方法論のうち、
lower boundだけで使えるstochastic MLしか使えない、との事。
SMLのあたりを見直すと、SMLはlog Zの近似として、前回の値から始めるMCMCを使う手法。（p604）

観測値をgivenとした時のサンプリングが簡単じゃないから、サンプリングして期待値求めるCD法とかは駄目らしい。

関係無いけど18章を読み直すと、positive phaseとnegative phaseの説明があるけど、こういう見方の説明はいいよね。
いろいろなアルゴリズムをそういう視点で考えると頭の中で整理もつきやすいし。

### PCD

PCDってなんじゃ？とindexを引くとp604に、stochastic MLの別名、とある。本の中ではせめてどっちかにしてよ…

### MP-DBM

DBMの実際のトレーニングの話で、
MP-DBMというのが結構長く扱われている。

Goodfellow 2013bとの事。これか。

[Multi-Prediction Deep Boltzmann Machines](https://papers.nips.cc/paper/5024-multi-prediction-deep-boltzmann-machines)

どうしよっかなぁ。読もうかなぁ。

読む事にした。

4.1が本体。その前の所も「収束の判定はコードが面倒になるからやってないが、十分回したからいいでじょ」みたいな事が書いてあったりやる気でるが、まぁいい。

で、Siというのは、予想したいターゲットを表すように見える。
それ以外がgivenの時の予想したいダーゲットの尤度を最大化している。

ただトレーニング時はどれがターゲットかは固定してないで、観測値の中から適当に決めてそれを予想する、みたいに動くっぽい。
なんでだろう。欠損値を再現する、とかならこれでいいだろうが、それ以外なら素直にyだけ予想する方が良さそうなもんだが。

4.2のMulti-Inferenceトリックは良く分からないなぁ。

あるSiに対し、fixed point equationから順繰りに更新するのを何周か回さないといけないが、これが遅い。

そこで少し回した後に次に行く、というのをMucti-Inference trick と呼んでいる。
ここまではいい。

で、これはRNNをたくさんの教師データで学習させてるようなものだ、と言ってる。
普通のRNNのトレーニングを考えると、1トレーニングexampleで収束するまで回す訳では無いのだから、それはそうだな、という気はする。

このfixed point equationによる更新をRNNと解釈出来る、という話は何度か出てくるが、いまいち良く分からんのだよなぁ。
自身の出力を次の入力としているからRNNの一種だ、というのはなんとなくは分かるのだが…

その次の別々のQの幾何平均を取る、と言ってるのが良く分からない。
一つのQを別々のexampleやSiでトレーニングしてると思ってたのだが…

あ、ひょっとして一つのOについて別々のSiでinferenceして、それの幾何平均を取るのか。
あー、そうっぽいな。なるほど。
確かにそれはdropoutっぽい。

4.3からあとは読まなくてもいいかな。本に戻るか。

## 20.5 実数向けBoltzmann Machines

開幕のモデルのGaussian-Bernoulli RBMsがいまいちで読む気が湧かないが、頑張って行こう。

mcRBMは平均と共分散をhidden stateとする、と言っていたが、20.44の方はただのRBMにしか見えないな。どのへんがmeanを学習するのだろうか？
なんか20.47あたりを見るとわかりそうなので先に進もう。

20.45のrってなんだ？と一瞬思ったが、これはWみたいなもんか。
2乗してるのでcovarianceっぽい気はするが良く分からん。

で、20.46となるのはいいとして、これをマージナライズすると20.47になるのかね。
これならmeanとcovariantっぽい物を学習している、というのは納得出来る。

ただ、covariance matrixがいちいち必要になるのは使い手は良く無さそうだなぁ。

mPoTとssRBMは燃え尽きたので読むだけ。
使う日が来たらちゃんと計算追おう。
みんなこの辺どうしてるのかなぁ。  

20.6のConvolutional BMsもなんで節が分かれてるのか良く分からないくらい前と同じ話。
CNNとの融合はpoolingをどうすべきかが片付いてないので難しそう、
という雰囲気しか伝わらず。まぁこの辺は元論文読まないと分からんだろうね。
ちょっとサボる。

### ボルツマンマシン関連、読み終わり

20.8まで一応読み終わった。
いまいち説明しているモチベーションを良く理解してない所があるので、RNN-RBMなどはいまいち理解はしてない（作れそうだけど）。

この本を読む前は、ボルツマンマシンって昔は流行ってたが今は別段流行ってなくて重要性もあまり無い、と思っていた。

でもこの本では結構な分量をかけてボルツマンマシンが解説されていたので、何か現代の様々な研究という視点からも重要性のある物なのかな、と思い、期待して読んでいったが、20.8まで読む限り、なんで2017年に出版された本でここまでボルツマンマシンを扱ってるのかは良く分からなかった。

全体的に参照されている論文なども2010年くらいまでのが多くて、いまいち現在の研究とのつながりが見えない。
Part 3はもっと現代の研究課題的な奴を扱うと期待していたのに。

これは

- たまたまここ8年間くらい流行ってないだけで、こちらか本筋（とgoodfellowが思ってる）
- 20.9以降の話題などの基礎になってる

などの理由があるならいいが、単にボルツマンマシンをひたすら紹介したが現在では要らない、というならがっかりなPart 3だな、という印象が強い。

とりあえず20.9以降を読んでいって最終的には判断したい。

## 20.9 サンプリングを混ぜたBack-Propagation

20.55式みたいなのでミューとシグマについてback propagationする、という話らしい。
具体的なユースケースを見ないとありがたみは分からないが、計算できる事は分かる。

その後離散値の時はgradがほとんどの場所でゼロになっちゃう問題を、期待値は連続になる、という場合について解く方法を説明してる。
難しい事は別段無いが、いまいちユースケースが良く分からないな。

そのあと、なんかvariance reductionというのを使うといいらしい、みたいな話がある。bを足しても結果が変わらないのは良い。で、baselineというbの式を求めて、そいつを学習から推計するらしい。
結構凝った仕組みだな。

参考文献で2014年とかが多いので、まぁまぁ新しい話らしいけど、自分は全然知らんなぁ。この辺は自分が無知なのだろうね。

## 20.10 Directed Generative Nets

なんか最初にSigmoid Belief Networksというのが出てくるのだが、なんでもかんでもintractableで全然駄目じゃん、
とか思った所、2015年にBengioとかがwake-sleepとか使って学習して結構良いパフォーマンス出している、というのを見て驚く。

なんかここまで全然現代の話しないなぁ、と思ってたのに、突然それまでの説明の応用で2015年の話をし始める。
こ、これは良いな。

で、その後のDiffentiable Generator Networksもなんか突然現代的な話になってるが、それがいい感じにこれまで説明してきた物の発展になってる。

そうそう、こういうのを期待して読んでたんだよ！p684まで来てようやくかっ！

この最後の30ページを読む為だけに、475ページからだから209ページ？前置きを読まないと行けない（関連論文も！）。

なんつーか、単にCNNとかencoder-decoderのモデルを理解するPart2までと、最後の30ページの間にはこんなにギャップがあるんだなぁ。
やばい。ギャップ有り過ぎ。

いやー、でもやる気出てきた！頑張って続き読むぜ！
