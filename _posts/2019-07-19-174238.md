---
title: "読書記録:ガベージコレクション"
layout: page	
---

<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=qf_sp_asin_til&t=karino203-22&m=amazon&o=9&p=8&l=as1&IS1=1&detail=1&asins=B01CYDGUT0&bc1=ffffff&lt1=_top&fc1=333333&lc1=0066c0&bg1=ffffff&f=ifr"> </iframe>

いろいろなGCについての研究を解説してくれる本。

最近のAndroid周りはGCとアロケータの改善が著しく、そうした議論にちゃんとついていけるようになる為に一度しっかり勉強したいなぁ、と思ってたので読む事に。

なお自分は、世代別GCあたりから実際を具体的には想像出来なくなるレベル。

# 1章 イントロ

### 並列と並行

どっちがどっちかすぐわからなくなるのでメモ。

並列はstop the worldするが、GC時に複数スレッドが動く、というもの。

並行GCはミューテータとコレクタの実行がconcurrentに行われる。

これ、書いてて気づいたが英語ならparallelとconcurrentなのか。英語の方がいいな…

### スマホが無い

1.3のスケーラビリティとポータビリティ、でマルチコアはデスクトップやノートPCでも一般的となった、と言っていて、スマホへの言及が無い。

まぁいいか、と読み進めると、1.5の実験手法で、コールドスタート効果を無視せよ、と書いてあるが、スマホではコールドスタートの速度はすごく重要なのでそれをベンチマークから取り除いて良いかは自明じゃない。
この辺はスマホかどうかの差は大きそうだよなぁ。

日本語版は2016年となっているが、原書は2012年。仕方ないかー。

### メモ

「ミューテータのリード、ライト操作」のところで、フィールド、srcのiがRootsの時、srcをRootsと書くとあるが、どういう意味だろう。

Rootsの定義は「ミューテータが他のオブジェクトを経由することなく直接的にアクセス可能な記憶領域にあるポインタ」となっている。

srcのiのアンパサンドがRoots、と書いてあるので、参照先がRootsという意味では無いな。このiフィールドのアドレス自体が「直接アクセス可能な領域にあるポインタ」という事か。
分かったようなわからんような。

シーケンスを列と訳すのはわかりにくいなぁ。順序つけて並べた物を表すらしい。

多重集合は順番は関係ないのか。Pythonのリスト表記だがあくまでmultisetな訳ね。注意が必要だな。

## 第一章、雑感

読み終わったので雑感など。
用語の説明などは日本語だと読みにくいな、と感じる。
和訳が悪いというよりも、こういう説明を日本語で読む事があまり無いのでスムーズに読めないのだよな。
原書の1/4くらいの価格だったので和書を買ってしまったが、込み入った内容は日本語は意外と辛いな…

細かいアルゴリズムが延々と続くのかと警戒してたが、意外と読み物的な部分の分量が多い。
といってもちゃんとアルゴリズムの解説
もありそうだし、なかなか良いバランスの本かもしれない。

イントロは最後の用語のところだけ一気に難しくなるが、実例無しで用語を語られても良く分からないので、適当に流し読みしつつ先に進むのが良いんじゃないか、とおもってそう進めてみる。

思ったよりも面白く読めてる。
たまにはこういう技術書読むのもいいな。

# 第二章 マークアンドスイープ

第二章から具体的なアルゴリズムの話にはいる。
といっても前半はstop the worldの間に一スレッドでコレクトする、という前提でのアルゴリズムの解説。

マークアンドスイープは二回くらい実装した事があるのでそれなりに分かるつもり。

### 2.1を読んだ感想

アルゴリズムの解説だが、すごく読みやすい。
知らない人が読んでわかるとは思えない部分もちょくちょくあるが、
この本を読む時点でこの辺の事は知ってる、という前提なのだろうな。

アルゴリズムの自然言語での解説が結構多くて、スラスラ読める。いいね。

### メモ

3色抽象化。黒は子供を見つけ終わった状態で、孫より先はまだ見つけてなくてもOK。

2.4のビットマップマーキング、セットアソシアティブ方式だと同じスロットになるからダメ、とか説明無しで書かれてて読者に前提とする要求水準にしびれるな。

2.4のPintezisとDetlefsのアルゴリズムの説明はわかりやすく書かれているな。
疑似コードの詳細の省き方と自然言語による説明のバランスが絶妙。これは良く出来てるね。

2.5は遅延スイープ。このアルゴリズム説明も良く書けている。
法2のK乗でマークする奴の一周回った時の説明か良く分からないな。
「そのため、これらは浮動ごみであり、マークルーチンによって辿られる事はない」という奴。

例えば256だとして、256だけ過去のGCサイクルでマークされたから浮動ゴミ、とはどういう意味だろう？256サイクルの間生き残ったオブジェクトは256になるのでは無いの？

## 2章の感想

2章はマークアンドスイープ。
基礎となるアルゴリズムは1ページくらいの簡単な解説で終わっていて、それに対する改善案がいくつか紹介されている。
改善案の方が分量は多い。

ちょうど基礎的な奴くらいは知ってるが改善案はしらない自分には勉強になった。
メモリのフラグメンテーションやキャッシュライン周りの話はそれなりに携わった事があるので、書いてある字面以上に多くを学べた気がする。

一方でマークアンドスイープを実装した事が無いと、この記述では簡素過ぎて難しさが良く分からないだろうなぁ。
だから「GCとか概要くらいしか知らないし、ここらで本格的に勉強するか！」という人向けの本にはなってない。
ただ自分にはこれでいいかな。

もっと難しくて不親切な本を予想してたので、良い意味で裏切られた。
論文の参照が列挙されてるだけ、とかかと思ってたが、良く要点だけを解説している。素晴らしい。
ベテラン向けにはこういう技術書を書きたいものやね。

# 3章 マークコンパクト

コンパクションというとコピーGCくらいしか知らなかったので、初めて読むアルゴリズムという事になる。

といってもオブジェクトを動かす事があるのはpinningとかしてれば知ってるので、言われてみれば当然こういうアルゴリズムもあるはずやね。

それにしてもコンパクションを圧縮と訳すのはやめてほしいなぁ。compress っほいやん。定訳なのかもしれないが、批判の対象が変わるだけで迷惑な事には変わりない。

### メモ

3.1 ツーフィンガー

めっさ簡単でびっくりした。なるほど、これでいいのか。

マークコンパクトは実装した事無いが、
ハンドルのコンパクションは結構実務で格闘してた時期があるので、解説はよく理解出来る。
人生何が役に立つかわからんね。

3.2 Lisp2アルゴリズム。
上書きがこれで平気かはちょっと考える必要があるが、考えれば分かるくらいには詳しく書いてある。良いね。

この位のシンプルさなら自分でも実装出来そうだな。

freeのnextはallocatorとセットで考えないと分からないよなぁ。直交してる、とかいう概念が直交してる事はほとんどないな。

要所に入る改善案の一言コメントとその論文への参照もいいね。何年、と書いてあるので、いつくらいの時代だとどのくらい高度なのかが分かるし。
そうそう、こういう本を読みたかった、という感じ。

ちょこちょこ日本語の文のつながりがおかしいが、疑似コードがあるおかげで意味の曖昧さは解消出来ている。
擬似コードと文章の説明のバランスが絶妙だね。
疑似コードもこれでは明らかに動かない、足りない重要な処理がたくさんあるが、アイデアを伝える事は出来てる。
これはなかなか良い説明方法だな。

3.3はスレッデッドコンパクション。初耳。
なかなか凝ったアルゴリズムで結構難しい。
説明も後方参照の説明が不十分に思うが、たぶん後方参照を見つけたらまたスレッド化するんだよね。

内部ポインタに対応出来ない、と書いてあるが、内部ポインタってなんじゃろ？

3.4 ワンパスアルゴリズム。これは早そう。
3章の中ではこれが一番だな。2004年と2006年か。CLRくらいの世代か。まぁまぁ新しいな。

アルゴリズム3-4はマークのビットマップはすでに出来ているが、オフセットは出来てない、という前提。
この辺はちょっとわかりにくいね。

アドレスからブロックを求めるのはコンパクションのコードでは良く出てくるので、この辺のコードは自分でも書けそうなくらいは理解出来た。

アルゴリズムの説明でちゃんと重要なケースを具体例に解説するのが素晴らしい。「ブロック2内の最初のマーク付きオブジェクトを考えてみよう」とか、「oldと書かれたオブジェクトを考えてみよう」みたいに。
ちゃんと手計算出来る図を用意して、説明と自分の理解があってるかを確認出来る。
これは名著だな。

## 3章読み終わり

大変勉強になった。内部ポインタがtwo finger以外使えない、という記述の意味は最後まで分からなかったが、他は割と理解出来たと思うし、発明が多くて読んでて楽しいね。

コンプレッサはアルゴリズムの名前なんだろうが、項タイトルは「ワンパスアルゴリズム」になってるのでちょっと分かりにくい。
こういう言葉の説明がちょっと分かりにくいところがいくつかあるが、アルゴリズムの解説が大変分かりやすく書かれているのでその欠点は吹き飛ぶな。

コンプレッサをちゃんと理解出来ればこの章は十分な気がした。他のは使わないだろうし。

# 4章 コピーGC

名前だけ知ってるコピーGC

### メモ

4.1 二分空間コピーGC。シンプルだがまぁまぁコードはちゃんと読まないと分からないな。

Cheney走査は日本語の解説がおかしい気がするが、アイデア自体がシンプルなので本当はどういう物かは予想出来る。

Moonのアルゴリズムも雰囲気は分かる。

オンラインオブジェクト再構成法はなかなか良さそうだな。2004年か。
この辺の世代はサーバーサイドVM早くなってきたなぁ、という印象あったが、GCの進歩も関係してるかもなぁ。

2006年あたりまで来るともう相当洗練されているね。

コピーGCって素人目には単純で無駄が多いからあんまときめかないけど、メリット多いよな。
アロケーション早いは確かに良さそう。

読み終わった。4章も擬似コードと文章の解説が絶妙で、図なども適切で、アルゴリズムの精緻さを考えると驚くほどわかり易かった。
コピーGC、お話レベルでしか知らなかったが、やれば実装出来そうだな、くらいには理解出来たし、2006年くらいまでの進歩もまぁまぁちゃんと理解出来た気がする。

# 5章 リファレンスカウント

リファレンスカウントに一つ章を割いている、という事に驚いたが、5.1以外はたしかにGCだな、という内容。

### メモ

リファレンスカウント、重い重い言われるがそんな重いイメージ無い。
だが確かに理由を説明されると遅いはずだな、という気もする。
リファレンスカウント使ってるシステムはランタイムが小さいので他のオーバーヘッドとかが影響してるのかもなぁ。 

「時代」という単語が定義されているがすぐ忘れるのでメモ。
プログラムの実行を区間に区切るときの、区間の事らしい。
epochとも言う。

延期型リファレンスカウントはヒープの走査が必要になるのであんまリファレンスカウントのお手軽さは無いな。
なお、ルートはヒープ以外のオブジェクトへの参照全部でスタックとかグローバル変数とか。

### 5.4 併合型参照カウント

併合型参照カウント法はアルゴリズム5-3を見ても良く分からないので、5-4のあとの例まで読み進めてから考える方が良い。

最初の参照と最後の参照だけ分かればリファレンスカウントの更新は出来る、
そして最後の値は今オブジェクトに入ってるから最初の値だけ記録しておけば良い、という事やね。

競合が起きても大丈夫、のくだりは良く分からないな。

1. スレッドAでログに書きはじめる
2. スレッドBでログに書き始める
3. スレッドAがオブジェクトを変更

で、スレッドBのログに最初のエントリじゃない物が入ってしまうと思うのだが。

いや、アルゴリズム5-3の12行目の時点でdirtyじゃないのなら、11行目はdirtyじゃなかったのが保証されているから追い越しは出来ないか。

ログに間違ったエントリが書かれる事はあるが、それを参照する事は無いな。納得した。

### 5.5  循環参照カウント法

リサイクラーはなかなかコードが複雑で、読むのは大変だな。
ただ理解してしまえばストレートではある。

最後がdecrementだったら循環ゴミ候補として紫に塗る。
markCandidatesでは紫な物の内部ポインタを全部デクリメントして灰色にする。
子供も再帰的に。
scanBlackで元に戻す。

AddRef-Releaseで育った身としてはRelease を無意識にデクリメントで読んでしまうのが辛いが、releaseはrcがゼロのときに呼ばれる。

76行目のコメントはたぶん誤植だな。これはフリーリストじゃない。

図5-3のaからのケースの解説を追ってみよう。

灰色に塗るのはmarkGrayのみか。
で、子供はgrayでもrcのデクリメントはやる（Yが0になる理由）。5-3 aから頭の中でmarkGrayして、bになるのを確認。

あれ？Aは-1になるような？いや、最初Aはデクリメントしないのか。

1. Aを灰色にし、子供のrcをデクリメントしてmarkGrayする。これでB-0（なんか名前が無いが）Y-1となる
2. Bを灰色にし、子供のrcをデクリメント、これでA-0, X-1となる、XはmarkGrayでさらに処理される
3. Xは灰色になり、Y-0となる。
4. Yが灰色になる。Z-0となりZは灰色へ
5. そのあともう一度YのmarkGrayが呼ばれるが、何もしない

でbになる。

X以外は0なので、scanでは、YやZは一時的に白になりうる。だがXは黒なので、その子供は全部黒になるから、黒で上書きされる。＞本文に説明もあった。良いね。

## 5章、おもったより勉強になった！

リファレンスカウントなんて大して学ぶ事も無いだろう、と思ったら、なかなか研究されてて高度な方法がいろいろあった。

またその複雑さを思うと、この本の解説はとても良く出来ていて感心した。
アルゴリズムを記述するだけじゃなくて、具体的な場合をいろいろ見て、図を入れて解説する、というのは見習いたい姿勢だ。

5章までで基礎となる手法を一通り解説した事になり、ここからはそれぞれの手法の比較やより進んだ手法の話となる模様。楽しみ。

