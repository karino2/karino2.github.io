---
title: UnionのGenericsでは、assignされてないタイプパラメータを持つ変数がありうる
layout: page
---
以前、[Genericsについてのメモ](https://karino2.github.io/2025/02/03/generics_memo.html)で、
IR上、より正確にはexpr上では全てのタイプパラメータは何かしらassignされている、
と書いたが、これは間違いだった。
というかジェネリクスのUnionをサポートすると間違いのケースが出てくる（それ以外では出てこない）。

以下のメモは自分の理解だが、あまり自信はないので間違っている所とかを見つけたら教えて下さい。

例えば以下のような型があるとする。

```fsharp
type AorB<'t> =
 | A
 | B of 't
```

この時、式の中で`A`とすると、この型は`AorB<'a>`となる。
fsxで試すと以下。

```
> type AorB<'t> =
- | A
- | B of 't
-
- ;;
type AorB<'t> =
  | A
  | B of 't

> A ;;
val it: AorB<'a>
```

ようするにofがないcaseの時だけ特別にこういう型の変数が出てくる。

このAはかなり特殊な型で、例えば以下のようなコードがあった時に、コメントにもあるように、
vの型が場所によって変わる。

```fsharp
let v = A // 1. ここでは、AorB<'a>型
if cond then
  v // 2. ここではおそらくAorB<int>型？
else
  B 123
somFunc v  // 3. ここではAorB<string>型にもなりうる
```

普通変数の型は解決されたら全て同じ型になるのだが、
このケースだけは参照されるコンテキストで型が決まる。
特にifのケースではelse節の型で決まると思う。

けれど1の所の変数の型は変わってない。それは3の所で違う型を期待する関数にわたす時にはその型になりうる事からも確認出来る。

これは、リストのnilの特別扱いの、より一般的なルールに見える。
nilは`List<int>`の型でも`List<string>`の型でも使える、特別なもの。

このAはそれと同じようなルールが適用される特別な何かに見える。

こういう、vのような変数はたぶんGolangでは作れない。

ただ実行時の値としてはどうせ中は空なのだから、なににでもキャスト出来る事が保証される。
だから変数の参照の所で目的の型にキャストするのはいつも出来る。
だからトランスパイラとしてエミュレートする事は出来そう。

自分の理解だと、vという変数の型は`AorB<'a>`で確定していて、
それを参照する所でコンテキストに応じて型が変わる、
と思っているが、この理解であっているだろうか？

実装としてはvを参照するごとに`'a`に別々のType Variableを振っていく、とかでいいのか？