---
title: Tiny SIMDを作ろう
layout: page
---

あらすじ。

[System Verilogを書くぞ！](https://karino2.github.io/2019/09/19/verilog_intro.html)でmipsを作ったが、せっかくFPGAをいじるならもっと並列度の高い事をやりたい。

という事でおもちゃのSIMDプロセッサを作ろうと思う。これをTiny SIMDと名付ける。

### 何を作るかを考える

まず作ろうと思ってる物を何も考えずに書き出してみる。

漠然としているが、4スレッドのSIMDを作ろうと思う。
データパスは4つの複製を持つ、という感じで。
目標としてはDRAMにJTAG越しか何かであらかじめ置いた画像データのヒストグラムを計算するプログラムを動かす、くらいにしておこう。

用語としては一つのスレッドをSPと呼ぼう。

コードはROMから読む事にし、DRAMはSRAMとの転送を明示的に行って使う事にする。
だからキャッシュは無しで。


### ブランチ処理を考える

ブランチの処理はSIMDっぽくどっちも実行される、という風にしたいのだが、
アセンブリ的にはどういう動きになるんだろう？
無制限のジャンプでは実現できないような？
考えてみるとCUDAレベルでしか挙動を理解してないな。

for文とif文が出来れば良いので、この命令から考えるか。

先へのbeqは間の命令をnop化する事で全SPで同じpcが使えるな。
そうか。前に戻る時も自分が動くまではずっとnopしてればいいのか。
つまり各SPは次に実行すべきpc（これをpcCandと呼ぼう）を用意していて、自分のpcCandより小さい命令はnopしていけば良いか。

branchとしては各SPのうち、一番小さいものが優先される。
そこからPCPlus4の間は順番に進み、branchの都度4つのSPの一番小さいpcCandが優先される。

おぉ、詳細は考える必要があるが作れそうな気がするな。

ジャンプは全SPが必ず一緒に動かなきゃいけない、という制約をつければいいかな。

### 追加する命令についてざっくり考える

他のSPがSRAMに書き込んだものが見えるようになる為には、バリアが要るな。
単一サイクルならその場で見えるから平気か。

パイプライン的には4回nopすれば良さそうかな。何にせよアセンブリ的には疑似命令でもsyncを足そう。
これを実行するとそれ以後は全SPのSRAMへの書き込み結果が見えるとする。

あとはSPのidが要るな。これは命令というよりはレジスタでいいか。31番をSPのIDとする、とかでいいか。

あとはDRAMからSRAMへの転送が要るな。
イメージ的には各SPが二次元画像の適当な行の範囲をコピーする事でSRAM上にタイルを作り、それを処理したい。
この転送ははみ出した時には勝手に0でも詰めておいて同じ幅をコピーすると割り切ってしまって良い気がする。

DRAMの開始アドレス、SRAMのコピー先アドレスの二つがあればいいか？一応幅も指定するか？
雰囲気としてはlw命令みたいなのでいいよな。
offsetはsramとdramは両方に適応してしまうか。

```
d2s $sramaddr, $dramaddr, #bothoffset
```

こんな感じか。逆はこうか。

```
s2d $dramaddr, $sramaddr, #bothoffset
```

どれだけの幅コピーするかはハードコードしてしまおう。
これはバースト長が絡むのでDRAM回りを調べたら決める事にしよう。

## DRAM回りを調べる

とりあえずAXI4でつなげるものらしい、との事だが、これを知らんので、まず以下を読む。

[Xilinx: AXI Reference Guide(pdf)](https://www.xilinx.com/support/documentation/ip_documentation/ug761_axi_reference_guide.pdf)

