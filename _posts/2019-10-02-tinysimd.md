---
title: Tiny SIMTを作ろう
layout: page
---

あらすじ。

[System Verilogを書くぞ！](https://karino2.github.io/2019/09/19/verilog_intro.html)でmipsを作ったが、せっかくFPGAをいじるならもっと並列度の高い事をやりたい。

という事でおもちゃのSIMDプロセッサを作ろうと思う。これをTiny SIMDと名付ける。

追記： SIMDなのにスレッドあるっておかしくない？と言われて調べたら、これはSIMTと呼ぶのが正しい用語らしい。知らなんだ。という事でTinySIMTと呼ぶ事にします。

### 何を作るかを考える

まず作ろうと思ってる物を何も考えずに書き出してみる。

漠然としているが、4スレッドのSIMTを作ろうと思う。
データパスは4つの複製を持つ、という感じで。
目標としてはDRAMにJTAG越しか何かであらかじめ置いた画像データのヒストグラムを計算するプログラムを動かす、くらいにしておこう。

用語としては一つのスレッドをSPと呼ぼう。

コードはROMから読む事にし、DRAMはSRAMとの転送を明示的に行って使う事にする。
だからキャッシュは無しで。


### ブランチ処理を考える

ブランチの処理はSIMTっぽくどっちも実行される、という風にしたいのだが、
アセンブリ的にはどういう動きになるんだろう？
無制限のジャンプでは実現できないような？
考えてみるとCUDAレベルでしか挙動を理解してないな。

for文とif文が出来れば良いので、この命令から考えるか。

先へのbeqは間の命令をnop化する事で全SPで同じpcが使えるな。
そうか。前に戻る時も自分が動くまではずっとnopしてればいいのか。
つまり各SPは次に実行すべきpc（これをpcCandと呼ぼう）を用意していて、自分のpcCandより小さい命令はnopしていけば良いか。

branchとしては各SPのうち、一番小さいものが優先される。
そこからPCPlus4の間は順番に進み、branchの都度4つのSPの一番小さいpcCandが優先される。

おぉ、詳細は考える必要があるが作れそうな気がするな。

ジャンプは全SPが必ず一緒に動かなきゃいけない、という制約をつければいいかな。

### 追加する命令についてざっくり考える

他のSPがSRAMに書き込んだものが見えるようになる為には、バリアが要るな。
単一サイクルならその場で見えるから平気か。

パイプライン的には4回nopすれば良さそうかな。何にせよアセンブリ的には疑似命令でもsyncを足そう。
これを実行するとそれ以後は全SPのSRAMへの書き込み結果が見えるとする。

あとはSPのidが要るな。これは命令というよりはレジスタでいいか。31番をSPのIDとする、とかでいいか。

あとはDRAMからSRAMへの転送が要るな。
イメージ的には各SPが二次元画像の適当な行の範囲をコピーする事でSRAM上にタイルを作り、それを処理したい。
この転送ははみ出した時には勝手に0でも詰めておいて同じ幅をコピーすると割り切ってしまって良い気がする。

DRAMの開始アドレス、SRAMのコピー先アドレスの二つがあればいいか？一応幅も指定するか？
雰囲気としてはlw命令みたいなのでいいよな。

DRAMに戻す場合は端の端数の処理が要るから幅が要る気もするが、その位はパディングしてしまえ、という気もするか。DRAMはどうせ余ってるだろうしな。
SRAMにコピーする場合は幅は要るか。

じゃあimmは幅にするか。


```
d2s $sramaddr, $dramaddr, #width
```

こんな感じか。逆はこうか。

```
s2d $dramaddr,  $sramaddr, #width
```

# 拡張アセンブリまとめ

作業しつつ間違いに気づいて直していったりしているので、最新の情報が分かりにくい。という事でここでは時系列では無く最新の情報をまとめる事にする。

### opコードとニモニック

mipsで自分がサポートしてない命令のオペコードを、DMAなどの為に使っている。

|使い方 |オペコード|メモ|
|------|------ |-----|
|`d2s $sramaddr, $dramaddr, #width`| 110001 (49)| DRAMからSRAMへのコピー。widthはワード単位(1widthで4バイト) |
|`s2d $dramaddr,  $sramaddr, #width` | 111001 (56) | SRAMからDRAMへのコピー。|
|`halt` | 001110 (14) | CPUを終了する。DRAMアクセスをjtagに切り替える。|



## DRAM回りを調べる

DRAM周辺は良く分かってない。

クロックが違うから注意が必要だよ、と教えてもらう。

通信はシンクロナイザ的なのを挟まないといけないのだろう。
普通はFIFOを挟んで来るまで止まるように書く、とか言われたが全然分からん。

JTAGでDDRに書き込むコードは昔書いた事があるとの事なので、教えてもらう。以下。

[shuntarot/arty-mig: Arty FPGA sample](https://github.com/shuntarot/arty-mig)

全然分からん。まずはこの辺といろいろ聞いた事をググる所からか。


### IP生成回りの資料

とりあえずAXI4でつなげるものらしい、との事だが、これを知らんので、まず以下を読む。（追記：これはハズレ）

[Xilinx: AXI Reference Guide(pdf)](https://www.xilinx.com/support/documentation/ip_documentation/ug761_axi_reference_guide.pdf)

良く分からん。
AXI4のpdfを読むのが先決っぽいが、もうちょっとこう、ゆとりっぽく始められないかなぁ。

お、動画発見。

[https://www.xilinx.com/video/hardware/creating-memory-interface-design-vivado-mig.html](https://www.xilinx.com/video/hardware/creating-memory-interface-design-vivado-mig.html)


なるほど、こういう感じか。さらに同じようなハウツー的なpdfを本家で発見。

[Zynq-7000 AP SoC および 7 シリーズ デバイスメモリ インターフェイス ソリューション v2.3](https://japan.xilinx.com/support/documentation/ip_documentation/mig_7series/v2_3/j_ug586_7Series_MIS.pdf)

だいたい上の動画と同じような内容だが、とにかくこういう感じでIPを作ってつなげる、という事は理解出来た。

さきほどのJTAG越しにDRAMに書くコードも読めば分かりそうという気分にはなった。
ただコードを読む前に実際にウィザードで作ってみて結果を眺めたいね。

### AIXの資料

AMBAの仕様書も読む。リンクがいかにも変わりそうな奴だったので自分がダウンロードした手順を。
まず以下に行く。

[AMBA Specifications – Arm](https://www.arm.com/products/silicon-ip-system/embedded-system-design/amba-specifications)

そしてLatest AMBA Specificationsというリンクをたどり、AMBA 4のAMBA AXI and ACE Protocol Specificationというのを読んでみた。
どうもこれで正解っぽい。

これは大変良く書けていて、最初からこれを読んでおけばよい、というたぐいの奴。
ただちょっと一般的すぎるので、もうちょっと軽くまとまっているのを途中で参照したくなり以下を見る。

[AMBA 3.0に追加された高性能バス用のAXI仕様 ―― チャネル方式を導入し従来のAMBAバスから大きく変更｜Tech Village （テックビレッジ）　／　CQ出版株式会社](http://www.kumikomi.net/archives/2007/08/31amba.php?page=7)

だいたい基本は理解出来たかな。

ただAXIの仕様の上限と実際のDDR3の上限はたぶん一致してないよな。
まずIP生成して叩いてみるのがいいのかなぁ。

### FIFOとかclock domainとか

FIFOとか非同期

- [http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf](http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf)
- [http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO2.pdf](http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO2.pdf)

概要は1を読む。実際の実装は2の奴を実装するのが良さそうか？FIFOはこの二つだけで良さそう。

- [https://web.stanford.edu/class/ee183/handouts/synchronization_pres.pdf](https://web.stanford.edu/class/ee183/handouts/synchronization_pres.pdf)

なんかググってたら見つかった講義のスライドだが、10ページ目あたりを見るとどういう物かわかる。

そのほか幾つかyoutubeでググってみてみたが、いまいちなのしか引っかからなかった。

### 必要な物について漠然と考える

FIFOを作ろうと思っていたが、よくよく考えるとDRAMとの転送は全スレッド同時に起こるのだから、CPUは全部止めていいはずだ。
だから必要なのはFIFOじゃなくて、同じSRAMなりBRAMなりをDMAっぽく転送する仕組みだよな。

もっと理想を言えば、lwとかswが来るまではばんばんs2dやd2sを発行して、
バースト長まで行ったらプロセッサ側を止めて転送をする、みたいな挙動がタイルを埋めるなら理想だよなぁ。
それってどのくらい難しいだろう？

むしろDRAMとの送受信は明示的に待つか。dsyncとか作って。
ただバースト長を計算して毎回そこでdsyncを書くのは辛いので、バースト長いっぱいになったらプロセッサは止まって欲しいな。
いっぱいになったら止まる、というのは結局FIFOか。ただ結果を置くのは共有SRAMでいいよな。

これならfor文でd2sでタイルを埋めて、dsyncし、以後はsramでいろいろ作業をして、
最後にs2dで結果を戻す、という感じで書けるので、かなりCUDA世代的にも納得のプログラムモデルだな。

ワープに相当するものが一つしか無いので、理想的にはタイルを処理している間に次のタイルをロード出来る方が良い。
イメージ的には、以下のように書ける方が望ましいが、、、

```

for(最初のタイル) {
    d2s();
}
dsync;
for(次のタイル) {
    d2s();
}
for(最初のタイル) {
    最初のタイルの処理
}
dsync;
```

だがこれはプログラムする側的にも複雑すぎるよな。
もっと初歩的に、

```
for(全タイル) {
    // タイルを埋める
    for(今のタイル) {
        d2s();
    }
    dsync;

    // タイルの処理
    for(今のタイル) {
        処理;
    }
    ssync;

    // 結果の書き戻し
    for(今のタイル) {
        s2d();
    }
    dsync;
}
```

くらいで十分か。
なんかだんだんと収拾がつかなくなってきたな。

この辺でとりあえず動かす目標を決めるか。


## 目標とするアセンブリを考える

いろいろとやりたい事が膨らんできてるが、そもそもこれは勉強目的のおもちゃプロセッサだ、という事は忘れてはいけない。
そもそもに掛け算とか剰余とかjalとかjrが無い。
必要に応じて実装しても良いが、学習効果が低いものはなるべくやりたくない。

そこでとりあえず実装する気になるサブセットを考える為に、具体的に動かすものを先に決めよう。

今考えているのは、matmulとヒストグラムの二つ。


### ヒストグラム

疑似コードで書くと以下みたいな感じか？

```
$result_base = 64K-256*4;
$result_cur = $result_base + $tid*256;
for($i = 0; $i < 256; $i++) {
    $sram[$result_cur+$i] = 0;
}

for($block = 0; $block < 640*480/(BARST_WIDTH); $block++) {
    if($tid == 0) {
        $dbase = $block*BARST_WIDTH;
        d2s($0, $dbase, BARST_WIDTH);
    }
    dsync;
    for($idx = 0; $idx < BARST_WIDTH/4; i++) {
        $bin = $sram[$idx*4+$tid]; // 1byteロード
        $sram[$result_cur+$bin] += 1;
    }
}
ssync;

$origin = $result_base+$tid*256/4;
for($i =0; $i < 256/4; $i++) {
    $i = $sram[$origin+$i];
    $i += $sram[$origin+$i+256]
    $i += $sram[$origin+$i+256*2]
    $i += $sram[$origin+$i+256*3]
    $sram[$rogin+$i] = $i;
}
```

結果はdramに書き戻すのが普通だが、今回はホストとか無いのでsramのままでもいい気はする。

対応してないのとしては、4で割るのと掛け算があるな。
掛け算は要るなぁ。
畳み込み出来ない奴は、4と256とBARST_WIDTHを掛けてる奴か。
シフトで行けるか？BARST_WIDTHがまだ分かってないが。

multを実装するのはいいんだが、hiとかloを使う気は無いので、レジスタに下半分入れる感じにする。
定数しか掛けないならmuliでいいか。

右シフト(srl)、muli、lbくらいか。この位なら大きな変更なしで行けそうだな。
いや、lbほんとうに要るか？各スレッドが4バイトずつ処理すればいい、という気もするな。これなら右シフトとandでandはもう実装してある。これでいいか。
じゃあ要るのはsrl, muliの二つだけか。

なかなかSIMTっぽくて、この位動けばいいよな。
1スレッド版と両方作って時間を比べたいね（まぁ転送コストがほぼ全てだろうから違いは出ないか？）

あとdramとの転送をしている間にsram上の処理を回すように直すと早くなるかとかも見てみたいな。

### matmul

とりあえず昔書いたCudaのコード

[Matrix Multiplication for CUDA explanation](https://gist.github.com/karino2/66b3f5e8fc01d6d0ffc44d3bbdf10bca)

を参考に、変更してみる。

```
#define TILE_WIDTH 16

// Compute C = A * B, 
// DRAM上に、行列A, 行列B, 行列Cと連続で置かれているとする。Cは結果。paddingとかは適当。
// 4K境界とかは今は考えない。

// この辺はとりあえず定数とする。あとでDRAMの先頭に置くかも。
int numARows, int numACols,
int numBRows, int numBCols,
int numCRows, int numCCols
int sizeA = numARows * numACols;
int sizeB = numBRows * numBCols;
int numTiles = (numACols - 1)/ TILE_WIDTH + 1;

/*
この三つはsram上で16*16*4バイトの領域。
*/
$tileA, $tileB, $tileC;

// trowとtcolはC上のタイルのインデックス。
for ($trow = 0; $trow < numCRows/TILE_WIDTH;  $trow++) {
    for($tcol = 0; $tcol < numCCols/TILE_WIDTH; $tcol++) {

        /*
        Aは上から$trow番目のタイルを左から右に動かし、Bは左から$tcol番目のタイルを上から下に動かす。
        この動かすインデックスが$tile。
        */
        for ($tile = 0; $tile < numTiles; $tile++)
        {
            /*
            Aの上から$trow番目を横にタイルを埋めていく。横方向に何番目かは$tileが表す。
            */
            for($i =0; i < TILE_WIDTH/4; $i++) {
                $inTileLine = $i*4+$pid;
                $tileLineABegin = ($trow+$inTileLine)*TILE_WIDTH*numACols+$tile*TILE_WIDTH;
                
                d2s(A[$tileLineABegin], $tileA[inTileLine], TILE_WIDTH));
            }
            /*
            端よりはみ出している部分は0で上書き。省略。
            */

            /*
            Bの左から$tcol番目のタイルを下に向かって埋めていく。下方向に何番目かは$tileが表す
            */
            for($i =0; i < TILE_WIDTH/4; $i++) {
                $inTileRow = $i*4+$pid;
                $col = $tcol*TILE_WIDTH+$inTIleCol;
                $row = $tile

                $tileLineBBegin = ($tile*TILE_WIDTH+$inTileRow)*numBCols+$col;
                
                d2s(B[$tileLineBBegin], $tileB[$inTileRow], TILE_WIDTH));
            }
            /*
            ここも同様に端からはみ出た所を0で埋める。省略。
            */

            dsync;
            /*
                $xと$yはタイルの中のインデックス。
            */        
            for($iy = 0; $iy < TILE_WIDTH/4; $iy++) {
                $y = $iy*4+$tid;
                for($ix = 0; $x < TILE_WIDTH; $x++) {
                    for (int i = 0; i < TILE_WIDTH; i++)
                        $tileC[$y][$x] += $tileA[$x][i] * $tileB[i][$y];
                }
            }
        }

        ssync;
        for($iy = 0; $iy < TILE_WIDTH/4; $iy++) {
            $y = $iy*4+$tid;
            $globalY = $trow*TILE_WIDTH+$y;
            if ($globalY < numBCols) {
                s2d(C[$globalY*numBCols],  $tileC[$y*TILE_WIDTH], min(TILE_WIDTH, 端までの幅));
            }
        }

    }
}

```

うーむ、出来たは出来たし、頑張ればこれをフルアセンブリ書くのも出来るとは思うが、
それを動かしてプロセッサの方までデバッグするのは辛いなぁ。
実装的にはレジスタ同士の掛け算、multくらい追加すればいけそうだが。

これはちょっとおもちゃの域を超えてしまっている気もするな。
命令セット的にはこれをサポート出来るような物を考えるが、ここまでの実装はたぶん無理かな。

とりあえずヒストグラムを動かそう。


## 最初の一歩

DRAM周辺がなかなか難しく、手が動かせないでいる。
とりあえず動くまでに必要な事が多すぎるので、
もっと小さく始めたい。という事で少し時間を掛けて方針を考える事にする。

### 最初に動かすもの

DRAMは外からデータを置く為の方法(jtag越しの接続)とCPUに転送する方法という二つのやる事がある。
だからまずこの二つを最低限動く形にするのが良かろう。

ヒストグラムでは転送は1スレッドだけで十分なので、最初は一リクエストでも良いはず。
ただ長さはまとめて送りたい。

XilinxのDRAMアクセスではコードが生成されるのだが、ここにはAXI4とUIという二つのインターフェースが選べるようになっている。
UIは単にデータを読み書きするだけの簡単なインターフェースになっているが、バーストとかは無い、という感じ。
最初はこのUIで転送する方がいいかもしれない。

コントローラにDRAMのアドレス、SRAMのアドレス、長さを置いておくと、ステートマシーンで1単位ごとコピーしていく、その間CPUは止める、という感じで良かろう。

うむ、まずはDRAMのコントローラとjtagでの転送を作る所からだな。
これならテストも出来そうな気がする。


### IP回りの試行錯誤1

とりあえずUIを作ると決めたので、migを使ってDRAMのIPを生成する。
基本的には以下の動画を参考に。

[https://www.xilinx.com/video/hardware/creating-memory-interface-design-vivado-mig.html](https://www.xilinx.com/video/hardware/creating-memory-interface-design-vivado-mig.html)

Vivadoのフォルダの中にdata/boards/board_files/arty-a7-35/というサブフォルダがあり、
この下にmig.prjというのがある。
自分のFPGAはarty-a7-35なので、これが自分のFPGAのメモリインターフェース生成の設定っぽい。
という事で分からない所はこのファイルの中身を真似する事にする。

以下ウィザードでやった事を簡単にメモ。

IP CatalogからMIG 7のウィザードを起動する。

Component Nameはmig7で。
AXI Interfaceはとりあえずdisable(UIしか使わないので)。

次のPin Compatible FPGAsは何もチェックせずに次へ。
次はDDR3 SDRAMを選ぶ。

次のOptions for Controller 0は分からない項目も多いので上記prjファイルの内容をほぼそのまま真似る。
PHY to clock controller ratioは4:1に変更。Memory PartはMT41K128M16XX-15Eに変更。
Memory Voltageも1.35Vに変更。Data Widthは16に。
Number of Bank Machineは良く分からないので4のままにしておく。
OrderingはNormalで。Memory Detailは以下になった。

```
Memory Details: 2Gb, x16, row:14, col:10, bank:3, data bits per strobe:8, with data mask, single rank, 1.35V,1.5V
```

次のInput Clock Freqはprjファイルでは166.6666 MHzになっているが、この値はなんだろう？
動画では500MHzを選んでいるので、DDRのクロックではないと思うんだよなぁ。
外から入れるクロックであって、内部では適当に変換されて166MHzになるんじゃないかな？

ちょっと分からないのでこのままデフォルトの310.078MHzのまま進めてみよう。

Output Driver Impedance ControlとRTTはprjファイルの真似をしてRZQ/6に変更しておく。
意味は分かってない。
他はそのままで次へ。

次のSystem ClockとReferential Clockは良く分からないのでDifferentialのままにしておく。
Internal Vrefはprjに従いチェックする。他はそのままで。
こういうデフォルトとprjの設定を変に混ぜるのは大丈夫なのかなぁ、とちょっと不安にはなるが分からないので仕方ない。

次は50オームのまま。

Pin/Bank selectionモード。ここはNew Designを選んでみる。ここが一番分からない所なのだが。
次のBank settingはそのままで次に進む。ここは動画を信じる。

次のSystem Signal Selectionはさっぱり分からないが、適当にかぶらないように以下のように選ぶ。
clk_ref_pにはA10/A9。
sys_rstはA11。init_calib_completeはA15。tg_compare_errorはA16。

次はOut of context per IP。

生成したものに何を入れたらいいか良く分からないな。
まずprjファイルを参考に、TimePeriodを3000に変更し、Input Clk Freqを166.6666MHzに変更、System Clockとref clockをno bufferにしよう。

でこの二つのクロック、どちらかはDRAMのクロックでどちらかはUIとかを動かすクロックなんだよな、たぶん。
教えてもらったjtagで転送するコードを見るとsys_clkに166Mhz, ref_clkに200MHzを入れている。
sys clkはInput Clk Freqで指定したものか。数字的にはDRAMのクロックっぽい？

ref_clkはなんだろう？Time Periodで指定されているクロックに見える。
このTime Periodってなんなんだろうな。良く分からん。まぁいいや、clock wizardでこの二つのクロックを生成してつなげてみよう。

clk_out1に166Mhzを、clk_out2に200MHzを指定しよう。これはいい。
問題はinputだな。CLK_INをsys clockにし、EXT_RESET_INをresetにする。CLK_IN2はそのままいじらず。
そのままgenerateしてみた。まぁ平気か？

次はjtag。あれ？jtagはaxiとつなぐ感じになっているな。
UIとはつなげないのか？ID_WIDTHだけ4にして他はデフォルトのまま生成してみる。

そしてなんとなくつないでみて、合成してみる。

とりあえずエラーで合成出来ない。
メッセージは以下のように出ている。

```
[DRC BIVC-1] Bank IO standard Vcc: Conflicting Vcc voltages in bank 35. For example, the following two ports in this bank have conflicting VCCOs:  
ddr3_ck_p[0] (DIFF_SSTL135, requiring VCCO=1.350) and led[1] (LVCMOS33, requiring VCCO=3.300)
```

ddr3_ck_pとledでVccが違う、と言っているように見える。
聞いたらどうもbankというので電圧は揃えてないといけなくて、普通ledは35、DDRは34とかじゃないか、みたいな話に。

以下のpdfにpinとバンクの関係が載っている。

[https://japan.xilinx.com/support/documentation/user_guides/ug475_7Series_Pkg_Pinout.pdf](https://japan.xilinx.com/support/documentation/user_guides/ug475_7Series_Pkg_Pinout.pdf)

確かに自分のmigウィザードではbank 35にassignされている。
このピンはfixedらしい、という事で、Pin/Bank selectionモードでNew Designがダメだったらしい。
全部手で設定するのはかったるいなぁ、と思ったら、手作業で生成したxdcファイルをもらってこれを読み込んだらピン指定が出来た。

で、Run Implementationしたら、

```
[Timing 38-282] The design failed to meet the timing requirements. Please see the timing summary report for details on the timing violations.
```

とか言われた。

warningでなんかresetピン回りの所で何か出ていて、ボードのmig.prjはNo connectionになってるな。
ウィザードに戻ってこのアサインをなくしてみる。

Bitsteramの生成までは出来たヽ（´ー｀）ノ

プログラムしてみよう。どうやるんだっけ？
Open Hardware ManagerでデバイスにAuto connectする。
次にProgram Deviceを選び、
TinySIMT.runs/impl_1/tiny_simt.bit　を選ぶ。

で、なんかプログラム出来たっぽいが動作確認方法が無いな。

なんとなく上記jtagでDDRをテストするレポジトリのmwとかmrを動かそうとしたが、

```
> get_hw_axis
WARNING: [Labtoolstcl 44-226] No matching hw_axi were found
```

とか言われる。
ltxというのを設定してrefreshしたら、以下のメッセージが。

```
INFO: [Labtools 27-1434] Device xc7a35t (JTAG device index = 0) is programmed with a design that has no supported debug core(s) in it.
```

何故debug coreが見つからないのかはよく分かってないが、とりあえずここまで来た結果割と理解が高まり、
教えてもらったjtagとDDRのテストのレポジトリの中身を大分理解出来るようになったので、次はこれを動かして違いを見てみよう。

### jtagとDDR接続するサンプルコードを動かす

友人が公開してくれてる、jtagと通信するコードのサンプルが以下にある。

[shuntarot/arty-mig: Arty FPGA sample](https://github.com/shuntarot/arty-mig)

当初はいまいち理解出来てなかったが、同じ作業をGUIでやった結果、それぞれの手順が何をしているかは割と理解出来た。
あとtclとmakeをインストールするのが面倒、と思っていたが、
このtclはvivadoの内部にあるtclで、vivadoにオプション渡すと起動するという事を理解した。
他の言語だと言語環境をインストールしてライブラリをロードするので無意識にそうだと思っていたが、
tclは組み込む形式の方が多いのだった。

まず、ipディレクトリに行き、powershellからvivadoをtclモードで立ち上げる。
以下の感じ。

```
C:\Xilinx\Vivado\2019.1\bin\vivado.bat -mode tcl
```

そしてMakefileを見るとarty.tclを実行する模様？sourceコマンドでやってみよう。
outputディレクトリが無い、と怒られた…作っておこう。

なんか14分もかかった…まぁいい。
次はBitstreamの生成。synの下に行って、outputをmkdirしてからtclを立ち上げて、またarty.tclをsourceで実行。

出来たっぽい？次はFPGAをつなげてprogram.tclを実行。出来たっぽいな。

さて、この時点でltxを指定すればjtag越しにmrやmwが動く、というのが自分の理解。試してみよう。

まずtest/01_axi_rwの下にcdしてtclを立ち上げる。

そしてrun.tclの冒頭のコード片を、PROGRAM.FILEをスキップして実行する。

```
set dev 0
set bit "../../syn/output/arty_top.bit"
set ltx "../../syn/output/arty_top.ltx"

open_hw
connect_hw_server
open_hw_target
current_hw_device [lindex [get_hw_devices] $dev]
set_property FULL_PROBES.FILE ${ltx} [lindex [get_hw_devices] $dev]
refresh_hw_device [lindex [get_hw_devices] $dev]
```

そうしたら以下のような出力に。

```
INFO: [Labtools 27-2302] Device xc7a35t (JTAG device index = 0) is programmed with a design that has 1 JTAG AXI core(s).
```

お、ちゃんと認識しているな。自分のケースと何が違うのかはまだ理解出来てないが、別にウィザードを使わないといけない理由もない。
次にjtag越しのmrとmwが動くかを試してみよう。

```
source io.tcl
mw 0 1234
mr 0
```

1234が帰ってきた。よしよし。

### マシン語とアセンブラを決めて、対応する

まずは単一サイクルのプロセッサでデバッグとかしつつ動かすので、それに最低限必要なマシン語だけ決める。
d2s、s2d、dsyncだけあればいいか（dsyncは要らないが、コードの互換性の為決めておく）。

付録BのMIPSのアセンブリを眺めると、FPコプロセッサへのロードとストア、というのがあるな。
これは今回の例では要らないので、このバイナリ値を使わせてもらおう。
という事で、

d2sはオペコードが110001（49）、s2dはオペコードが111001 (56)としよう。

dsyncはsyscallを使うか。ssyncはbreakかでいいか。
という事でdsyncは001100 (12)、ssyncはまだ使わないが001101 (13)としておこう。

d2s、s2d、dsyncを簡易アセンブラに実装する。
ここはあとで上で書いたアセンブリのメモと統合しよう。

アセンブラは完成。

### 単一サイクルのプロセッサを持ってきて動かす

とりあえず一番簡単な、単一サイクルのプロセッサをつなげる。
以前作った奴を持ってきて手直ししてテストベッドで動かす。

今回のコマンドラインの環境で動かす為にいろいろ整備。
元のgithubではmakeを使っているがそんなものは無いので、PowerShellファイルで簡単なスクリプトを作る。

compile.ps1でコンパイルとelaborateをやる（後者が何かはよく分かってない）。
run.ps1で実行する。clean.ps1でクリーン。

一応単純なaddが動く所までは確認。
おぉ、GUIより大分早いな。こちらの方が良さそう。

シミュレーションではDRAM回りはめんどくさそうなので、プロセッサ回りだけやっておいてipが絡むのはFPGAで動かしてしまう事にする。ゆとりなので。

### 単一サイクルプロセッサとDRAMのつなげ方を考える

次にこのプロセッサをDRAMとつなげる方法を考える。
プロセッサからはsrc_addr, dst_addr, widthとコマンドの線を出す。
アドレス自体は32bitも要らないはずなんだが、まぁ32bitにしとくか。

で、リクエストが来たらプロセッサをストールさせて、状態マシーンが転送の面倒を見る、という感じでどうだろう。
ストールから再開する時に同じ命令が来ないようにする必要があるな。
ストールしたらinstrを0（nop）にしてPCのフリップフロップを止めれば十分か？
再開した時もう一回メモリの命令が呼ばれそうな気もするな。ここはちょっと考える必要がありそう。

DMACのような物を作れば良さそう。
DDRの読み書きはとりあえず4バイトずつ、jtag越しに読み書きするのと全く同じ仕組みでやろう。
jtagの線とDMACの線をマルチプレクサでつなげる感じ。

d2sとs2dは分けて考える方が良さそうだな。

書いていて、jtagとCPUの切り替えはCPUのhalt的な状態が欲しくなる。
halt命令も追加して、haltピンを出すかな。

haltはsyscall, breakの次という事で001110にしよう。

d2sのwidthはワード単位（4バイト単位の幅）としておく。
本来はバイト単位が良いのだろうけれど、どうせやらないと思うので、ミスの余地が無いように。



### 実機でのテスト方法を考える

構成要素のテストはシミュレーションでは一応動いた。
そろそろ実機でテストしたいが、どうしたもんか。

テストが成功してたらLEDを光らせる、みたいなのを考えていたが、これはtopでやるのは意外と面倒。
それよりはアセンブリからLEDを光らせる方が良さそう。

という事で、sw命令の0x8000_000Xはledにマップする。

- 0x8000_0000: `led[0]`
- 0x8000_0004: `led[1]`
- 0x8000_0008: `led[2]`

lwはいいだろう。
なお`led[3]`はhaltしているかどうかにつなげる事にする（halt中はjtagに切り替わる）。

現状はシフトを実装していない事に気づく。lui実装する方が簡単か？
luiの場合はluiとoriが要るな。oriは別にaddiでもいいか。いや、ビットがめんどくさいか。oriが要るな。

実装しよう。実装した。

## デバッグ作業

という事で一番シンプルな、DMAの間はCPUを止めて、DMA要求は一度に一つで、
CPUはmigのui_clkで動かす、という構成でコードを書いてみた。

いろいろ合成時のワーニングを消したりしている。

こんなシンプルな構成でも思ったよりも大変だなぁ。
DMAはこのままこの単純なのだけで行き、プロセッサの方をSIMTに出来たら終わりでいいかなぁ。
両方ちゃんとやるのは大変過ぎるし、この手の物は、あくまで勉強目的という事を忘れてはいけない。

dmacでfound timing loopというCRITICAL WARNINGが出ているなぁ。
見た感じ状態マシンっぽいが。


### リセットボタンの振る舞い

どうもリセットがずっと1だな。
一方で自分のコードは全部リセットが1の時にリセットされると書かれている（教科書の通り）。
うーむ、逆にすればいいのか？

ググっていたら、リセットは普通1で、ボタンが押されている間は0と以下のサイトに書いてあった。
[Arty Reference Manual [Reference.Digilentinc]](https://reference.digilentinc.com/reference/programmable-logic/arty/reference-manual)

なるほど、そういうものなのか。どうしようかな。とりあえず自分が書いた所では`!ui_clk`を食わせてみるか。
一応最後までいってhaltを表すledがついた。
ただそのあとjtagでDDRにつなげると動かない。

ボタンを押したらddr contollerとjtagだけリセットしてみるか。

＞ダメだった

### シミュレータでddrを動かす

シミュレータではipは動かせないか、動かせるにしても凄くめんどくさい、と思ってあきらめていたのだが、シミュレータ用のモデルがあってmigは動かるよ、と教えてもらう。
しかも元のレポジトリでやってるとの事。

ほぉ、それが出来れば大分いろいろ調べられるな、という事で、真似をしてシミュレータでddrを動かす事にする。

確かに真似してシミュレーションで走らせると動いているように見えるのだが、
calibrationが終わるまで結構時間がかかり、そのあとストップ呼んでからも結構止まらない。
やはり複雑なIPが絡むとテストは大変だなぁ。

最初の段階でarreadyが立ってないとかいろいろ予想とは違う振る舞いを見て、AXIとはそもそもどういう物かを調べている。
この手の正しい挙動を調べる対象があるって大切だよなぁ。答えを知らずにテストを書いても意味が薄い。
DDRをシミュレータで動かすのはたぶん自力ではできなかったと思うので、ここまでは自力ではこれなかったな。

そしてあるチャンネルでreadyが立ってvalidが立った後に、他のチャンネルのvalidを待ってる時にreadyが倒れる、みたいなケースがある事を理解する。
一度でもハンドシェイクが成立したらそれを覚えておく必要があるのだな。

さらにハンドシェイクというのは成立したクロック数だけリクエストが発行されるとみなされるので、
1リクエストの時は一クロックしか成立しないように書かないといけない、という事を理解。なるほど。これはなかなか組み合わせ回路的だな。
fifoの挙動を誤解していたのでこの辺を読み解けていなかった。

ハンドシェイクは1クロックだけ成立するように直してシミュレーションが無事通る。長かった。

実機でもhalt後にjtagで読み書き出来るようにはなった。
だが、ここで期待する値をdramに書き込んでCPUをリセットしても、ledの光り方がfailの時のなので、sramへのコピーは失敗している？

理解が深まったのでシミュレータ上で期待するddrの振る舞いをハードコードしたテストを追加してみると、ちゃんと動く。うーん。これが動くなら実機でも動きそうだけどなぁ。

### 実機でのトラブルシュート

挙動を理解すべくもっと単純なプログラムに差し替えていろいろjtagから書く値を変えて試したところ、どうも変な値がコピーはされていそう。
なんか0004から読み込むはずが0008や000Cから影響を受けているな。
ビットはばらばらで規則性は良く分からない。

もう少し解析しやすいように、逆にsramからddrへのコピーのテストコードを書いて動かしてみよう。
途中でswのバグを見つける。ALUのctrlにfunctを見ているがopcodeが0の時じゃない時に、immなどを間違ってfunctと思って動く事がある。
まぁいろいろバグはあるな。

という事で直してシミュレーションで動いたので実機に合成してみる。

お、こちらはちゃんと意図通りに動いていて、期待した値が書き込み出来ている。
どういう事だ？さっき直したバグは問題が出るならシミュレーションでも見つかるはずなので影響は無いはず。

とにかくs2dは動いた。d2sのデバッグを続けよう。

s2dが動いたので、DDRからの読み込みでは無くその先、というか切り替えのあたりとかSRAMへの書き込みとかで変になっている可能性も出てきた。

まずddrから読んだ物を別のddrのアドレスにコピーするコードを書いてみよう。
これでビットパターンがどうコピーされるかをjtagで調べられるのでledで1bitを検証するよりはヒントが多くなるはず。

ddrー＞sramー＞ddr のコピーは正しく動いた！どういう事だ？

sramからいったんレジスタにロードして別のsramの場所に書き込んで、それをddrに書いてもちゃんと書かれている
（ただし順番は変えた）。
これは間にbeqとかledへのswが無いだけで動いていないテストコードとほとんど同じ事をやっていると思うのだが…
動かない場所をより詳細に確認すべく書いたコードが動いてしまった。

とにかく、当初思っていたよりもDMAはずっと動いているようだ。ただ何故か最初に書いた二つのテストコードだけが良く分からないバグをつくらしい。

動いた物

- s2d_test.s
- dram2dram_copy_test.s
- dram2dram_register_test.s

動かない物

- d2s_test.s
- d2s_simple_test.s
- d2s_simple_writeback_test.s

どうしようかな。
現状は何か試す都度2時間くらいかかるので、あまり再現条件を絞り込んだりできる気はしない。
一方でより複雑にしていくともうどうにもならなくなる未来も見える。

うーん、もうちょっと他のコードもいろいろ書いてみるかなぁ。