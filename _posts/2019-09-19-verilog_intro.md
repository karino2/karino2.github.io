---
title: System Verilogを書くぞ！
layout: page
---

[読書記録: ディジタル回路設計とコンピュータアーキテクチャ](https://karino2.github.io/2019/09/09/000435.html)を読みながら、いろいろ書いてみる時の記録。
環境設定とか適当にやってしまって記録が残ってないが、心を入れ替えてここからは記録を取る。
FPGAでLチカくらいはやった。

まずVivadoというIDEで開発していく事にする。あまりにもかったるかったらエディタでの開発環境を整えるが、ゆとりとしてはIDEでぽちぽちやりたい。

以後System Verilogを書いて行くが、面倒なのでVerilog、と記す。ゆとりなので細かい事は気にしない。

### 初めてのテストベンチ

細かなモジュールとかを書いて挙動を調べるのは、シミュレータというのでやる物らしい。
で、シミュレータではテストベンチというのを書いてモジュールをテストするらしい。

という事で、このテストベンチで何かをテストする、というのを書いてみる事から始めたい。
題材としては、書籍の4.9にテストベンチのコードがあるsillyfunctionでやってみる。

とりあえずプロジェクトを作る。
4章の演習問題を全部一つのプロジェクトに入れるのは取り回しが悪そうなので、3つくらいのプロジェクトに分けるかな。
chapter4_1というプロジェクトを作る。

次にsillyfunction.svというファイルを作り、sillyfunctionの実装をへこへこ書く。

テストベンチは普通はファイル分けるらしいが、今回は動作確認なので同じファイルでもいいかな。
ちょっと同じファイルにテストベンチも書いてみよう。

モジュール名はchapter4_1の前半で被らないように、testbench_sillyfunctionにしよう。長いがゆとりなので。

中身としてはとりあえず000と001のテストだけ書いて動かしてみよう。
どうやって動かすんだろう？

Runのアイコン（緑の右三角）を押して、Run synthesisというのを選んでみた。右上の所に Running synth_designって出てくるくる回ってる。しばらく待つか。
お、合成が成功した、と出てきて、三つの選択肢が出てきた。Run Implementationを選んでみるか。

おや、エラーになった。Design is emptyとPlacer could not place all instancesと言われた。

走らせたものが間違っているのか？なんか前はRun simulationというのを選んでビヘイビアがどうこう、とか選んだ記憶があるな。

左のペインにRun simulationというのがツリーのSimulationの中に入っているな。これを選んでみるか。
おー、出来た。波形が見れる。いいね。

少し変えてみた。ちゃんと動いてそう。よしよし。
一応failしたケースの挙動も調べておくか。`$error`というのを使っているのだが。assertをfailするように変更。

ん？何も起こらないが。
しばらく格闘した結果、Tcl consoleに出ているが流れて気づいていなかった、という結論っぽい。
`$display`というのもあるな。これは標準出力に出す、errorは標準エラー出力に出す、という所か。なるほど。

よし、これで作業を続けていけそうだな。

現状、Run Simulationとやると全テストベンチが流れてしまう。これはちと都合が悪いな。
選んで実行とかできないのだろうか？
Disable fileというのがあるな。これでテストをdisableにしておけばいいのか。

### 演習問題 4.3 xorを実装せよ

やってみよう。xorは予約語だから使えない、と言われた。myxorという名前にするか。

4入力のxor、期待する振る舞いはなんだろう？多入力ゲートは1.5.6節にあるな。
TRUEが奇数個ならTRUEを出力するらしい。

どう実装するのがいいかしら？4入力なら組み合わせは16個か？TRUEになるだけでいいので半数の8個くらいか。
この位ならcaseで書けばいい気もするな。

caseを使う場合はassignでいいんだっけ？4.5.4を見ると、caseを使う場合はブロッキング割り当てを使うのが良さそう。
それぞれの違いを軽く見直しておく。ノンブロッキングは並列に評価されるみたいな挙動か。
一応説明を読み直したが、とりあえず心を無にしてこのガイドラインに従って、always_combの時はブロッキング割り当てを使おう。

caseでは奇数でも偶数でもどちらか一つをセットすれば良い。
奇数個と偶数個はどっちが少ないか？偶数個は2個と4個。4個は一通り、2個は4C2で6通りか？
奇数個は1個と3個でどちらも4通りか。おや。偶数個の方が一つ少ない。まぁ一つくらいならいいか。

よし、出来た。
`logic [3:0] a, y;`とやったらyも4bit幅になっているというバグを入れてしまっていたが、無事デバッグも出来た。
よしよし。

### レポジトリを作ろう

進捗を見せるという点でも、githubに上げておく方が良かろう。という事でレポジトリを作りたい。
プロジェクトのディレクトリを眺めると、chapter4_1/chapter4_1.srcs/sources_1/new の下だけで良さそうか？
newってのが何なのか知らないが。

この本の英語名はなんだっけ。DDCAでいいか。ではDDCA_exerciseで行こう。
レポジトリ一つに全部入れたい気もするが、XilinxのIDEの構成と共存するのが難しいな。

シンボリックリンクを貼ったらgitはsymlinkはadd出来んと言われる。そうか。
ハードリンクなら？と思ったがハードリンクはファイルごとにやらないとダメそう。そりゃそうだな。

うーん、逆にxilinxの方のディレクトリをシンボリックリンクにしたらどうだろう？やってみよう。
mklinkコマンド、ちょくちょく出番あるよな。

よし、ちゃんと動いているね。

[https://github.com/karino2/DDCA_exercise](https://github.com/karino2/DDCA_exercise)


### 4.5 minotiry

少なくとも二つの入力がFALSEならTRUEを出力する。
という事は、~a~bc+~ab~c+a~b~c+~a~b~cか。
簡単化出来るか？~a~b~cがあるから、真の部分はいらないな。
~a~b+~a~c+~b~cか。ま、この位でいいな。

あ、Verilogはアンドと縦棒か。`~a&~b|~a&~c|~b&~c`か。
まぁブログ的にはmarkdownに優しいブール代数表記でいいか？

よし、動いた。

### 4.6 hex display

16進数のディスプレイ表示。例題2.10に10進の表示があるので、変数名などはこれをベースにする。

あれ？Bと8ってどう区別するんだ？Dと0も一緒だよな。小文字にすればいいか？
aとかは小文字だと読みにくそうだな。bとdだけ小文字にするか。

ローマ字の所での各セグメントのうち、1になる所だけ列記する。

- A abcef
- b cdefg
- C adef
- d bcdeg
- E adefg
- F aefg

こんなもんか。あとは心を無にしてそのままVerilogでずらずら項を書いて行くかな。
assignをひたすら並べていけばいいか。

aはだいたいあるから無い方を入れる方が楽か。
0になるケースを考えると~0001+~0100+~1011+~1110か。これの否定だな。

うーむ、これを`d[0]`とか`d[1]`とかで書くのはだる過ぎるな。case使うか。

あれ？記述例4.24に10進数の例があるな。モジュール名や変数名はこれに合わせるんだったなぁ。
変数名は今からでも遅くないか。
これだと7変数に一気に入れている。どうせcase使うならこっちのほうが楽か。真似しよう。

10進のコードを写経するのがだるいな。まぁこの位は修行と思って頑張るか。

これ、書いたはいいがテストって何書くんだ？入れた値が出てくる、としか書けないよなぁ。
表示できないと盛り上がらないなぁ。手元のFPGAを見たが7セグメントディスプレイは無いか。
LEDはあるが、数字が出ないと盛り上がらないよなぁ、やっぱ。

aの時だけテストして波形を見て満足したので次に行く。

### 4.8 mux8 (8:1マルチプレクサ)

前に4:1がどっかにあったなぁ、と見直すと、4.2.4の記述例4.5とか4.6でその辺をやっている。
d0とかyは3:0っぽいな。
これもcase文でずらずら書く方が早いな。というかこればっかだな。

次の4.9はy = a~b+~b~c+~abcをmux8で書け、との事。答えを全部ハードコードしろって事か？
まあ大した事無いが意味は分からんな。

次の4.10では4:1を使って書け、とある。notはいくら使っても良い、とあるが、別にmux4を3つ並べればnotは使わない気がする。
逆にそれ以外の場合、何が出来るというのか？
もともと一行で片付く論理回路をあえてmuxを使うとうい問題なので、何がOKで何がNGか良く分からないな…

その他、mux4版やpriority8なども作る。特に問題無し。

### 6:64デコーダ

2:4デコーダーを作れ、との事。
2:4ってどういう意味だっけ？と前を見直すと、2bitの値を4ビットのワンホットにデコードする、という意味らしい。
なるほど。
case文で一瞬な気がするな。やっていこう。

次に6:64デコーダを作れ、と言う。
おや、assignを64個並べれば出来るだろうが、さすがにそれは無いだろう。どうしたらいいんだろう？

とりあえず4っつくらい代入してみよう。

```
   assign y[63] = high[3] & mid[3] & low[3];
   assign y[62] = high[3] & mid[3] & low[2];
   assign y[61] = high[3] & mid[3] & low[1];
   assign y[60] = high[3] & mid[3] & low[0];
```

最後の列以外は一緒なのか。つまりブロードキャストみたいな事が出来れば良さそうだな。
条件割り当て使えば出来るのは分かるが、インストラクションはAND回路だけで出来そうな書き方だよな。

ハードの人に聞いた所、`{4{high[3]}}`みたいな書き方でいいとの事。なるほど。
ではこれを激しくやっていくとこうか？

```
    assign y = {{16{high[3]}}, {16{high[2]}}, {16{high[1]}}, {16{high[0]}}} &
         {4{{4{mid[3]}}, {4{mid[2]}}, {4{mid[1]}}, {4{mid[0]}}}} & {16{low[3:0]}};

```

相当激しい感じだが、なんか動いている風味だ。

## ここまでで4章の演習問題は良しとしよう

だいたいVerilogのコード書き溜めとしては十分なくらい出来たし、デバッグ回りや波形の見方、IDEの使い方なども慣れてきたので、ここでやるべき事はマスターしたといえるだろう。
まだまだ演習問題はあるが、4章の演習問題はここまでにして、次に進もう。

# 5章 デジタルビルディングブロック

最初はいろいろな加算器を実装したりしようと思ったのだが、なんかこういう普通はやらない事をせっせとやる前に、普通やる事をマスターする方がいいよな、という気になる。
という事でとりあえずALUから作ってみるか。

### 演習5.9 図5.15のALUを実装せよ

adderとかのVerilogコードはあって途中まで見ながら書いていたが、これは回路図から実装する方がいいか。
という事で、adder, subtractor, comparatorなどを実装していこう。とりあえず32bit決め打ちで。

zero extendはどう書くのだろう？普通にbit連接でいいのかな。まぁそれでいこう。

あ、comparatorは要らないのか。まぁいい。そしてmux2とmux4が要るな。
前のプロジェクトからコピペで行こう。この辺は変に共有せずにdupする方が演習問題の記録としては良かろう。

なんか回路図の通りにつなげていったらあっさり出来てしまったな。めっちゃdeclarativeだなぁ。
むしろこの回路図を書くのを自分でやらんといけない気がするな。まぁいい。テスト書いてみよう。

最初はZZZZZZとかだったが、いろいろ直して全部動くように。
なんかALUが動くと感動があるね。ここより上の世界は結構なじみがあるので、なんかゲートからつながった感があって感動がある。

### 次は何をやるか

演習問題ではシフタとかいろいろあるのだが、ALUが出来たらもういいんじゃないか、という気がする。
7.3.2のmipsの単一サイクルの回路図を見ていると、組み合わせ回路で必要そうなのは全部書けそうな気がするな。

だが、フリップフロップやメモリ、レジスタファイルは書いていない。これは書いておきたいな。
という事で次は順序回路系の必要な奴を書いてみたいな。

7.3.2の図からまだ書いていないのは、

- メモリ
- レジスタファイル
- PCのフリップフロップ

の三つかな。これら三つを書いて行こう。

まずはPCの為のフリップフロップから。これは簡単なはず。リセット付きの奴を書いておこう。
4.4.2に答えがあるのでうつせばいいのだが、とりあえず見ずに書こうとしてみて、どこでつまるかを確認しておく。

命令メモリとデータメモリは線が違うな。データメモリで代用出来そうだが、練習の為に別々に作ってみるか。
ではまずは命令メモリ。coderomと名付けるか。

## ROMを作ろう

という事でROMを作る。

とりあえず書いてみて思ったが、メモリの中身を初期化する方法が無いな。どうするのだろう？
書き込み可にして初期化時に書き込めばいいのかもしれないが。

うーん、本来は外部のメモリは既にあって、そこへのロードとかはCPUを動かす前にやるよな。
FPGAならなんかメモリユニットみたいなのがあって、tclとかで送れるんだよな、たぶん。
mipsの課題の模範解答のファイルを見ていると、ファイルから読みだしているな。
これではシミュレーションでしか動かない訳だが、本番は実際のデバイスのメモリに差し替えるのかね。

### readmemh

普通はどうするものなのか気になったのでハードの人に聞いてみた。
どうも`$readmemh`でファイルから読むようなコードを書いておくと、実際のROMに合成されるらしい。
まぢで！？凄いな、Verilog。

これをどこで読むかというと、initialで読むっぽいな。この辺この本には全然説明無いが、回答例で使われているのはずるい。
ま、この位はググって調べよう。
readmemhでググって以下がひっかかる。

[Initialize Memory in Verilog — Time to Explore](https://timetoexplore.net/blog/initialize-memory-in-verilog)

なるほど。ただアットマークでアドレス指定出来ると言ってた気がするな。その辺はこっちに書いてある。

[Modeling Memories And FSM Part - I](http://www.asic-world.com/verilog/memory_fsm1.html)

なるほど、そこから先はシーケンシャルになるのか。なんかこのファイルのパーサーとか仕事で書いた記憶があるな。

まぁだいたいイメージはつかめた。

### mipsのコード領域を確認

今回はOSを載せたりする訳じゃないので、コード領域はROMをそのままマップすればいいだろう。
仮想メモリもやらんだろうし。

という事でアドレスの範囲とか確認しておく。6.6.1のメモリマップによると0x0040_0000から0x0FFF_FFFCまでだって。
広いな！256MBだって。うーん、そんなROM要らん気もするが。

1ワード4バイトなので、32-8で24bitあれば全部飛べるか。でもROMそんな要らないよなぁ。
由緒正しく64kくらいにしておくか？64K byteの場合、2^6*2^10か。32 bit単位でいくと、16 K ワード。この位でいいか。
アドレッシングとしては、4+10で14bitだな。

回答例を見ると6bitになっているな。64ワード？さすがに小さすぎじゃないか？それは。まぁいい。自分は16Kワードで行こう。
アドレス線は14bit。

ROMは組み合わせ回路として、clk無しでその場で読みだされるとしよう。

一通り実装して動くのを確認。よしよし。

## レジスタファイルとSRAM

レジスタファイルはコード例が無いな。SRAMとVerilog的には大差ない感じでいいか。
やってみよう。

まずはinputとoutputを図5.47を参考に決める。こんな感じか？

```
module regfile(
    input logic clk,
    input logic [4:0] a1, a2, a3,
    input logic we3,
    input logic [31:0] wd3,
    output logic [31:0] rd1, rd2);
```

we3の場所をclkの下にするかwd3の前にするか悩ましいが、まぁ適当でいいか。

で、4byteのレジスタを32本用意すればいいんだな。これはlogicでいいか。

割とそのまま書いて、なんとなく動いている風味。

次はメモリ（SRAM)だが、むしろポートが少ないだけで同じだよな、これ。
サイズはROMと同様64K byteとしておくか。アドレス線は14bit。
この辺はテスト書く方がだるいな。

### これで7章の単一サイクル版で必要な物がそろったと思う

とりあえずmipsを作るのに必要な要素はそろった気がする。
他にも演習問題とかいろいろあるが、とりあえずここまででmipsを作って動かしてみたいので、CPU設計に入ろう。
足りないものがあったらその都度戻って作れば良いだろうし。

ここまで書くとVerilogの書き方も大分慣れてきて、回路図があればVerilogに翻訳するのは大分出来るようになった。
回路図を書くのがハードウェアプログラミングだという話もあるが。

Vivadoで波形みたりクロックを入れたりしてテストしたり、そういう当たり前の事をあたりまえに出来るようにはなった気がする。
という事で次は一番簡単なCPUを作ろう。


# 7章の単一サイクルmipsプロセッサ

ここはじっくりやりたい。
個人的に、汎用のCPUを作れるようになる事にはそれほどの意味は感じていないので、
あまりCPU特有の事に深入りするよりは、一番単純な奴をしっかり理解して、
むしろSPU並べたSIMDとか作れるようになりたい。
という事で単一サイクルをまず時間を掛けてやる。

## 回路図を描く

既にある回路図を見ながら実装するのはやれば出来ると思うので、勉強の為に回路図を描く所からやろう。
本文の内容に沿って発展させていきたい所存。

描くのはタブレットでやりたいが、そうすると本を読むのに別の何かが欲しいな。
Paperwhiteで読めるか？お、読めるな。これで行こう。

### リセットアドレス

リセットアドレスは0にしたい、と書いてあるが、NULLを読むとコードが読めてしまうのはちょっと気分が悪いので、mipsのメモリマップの先頭アドレスである0x0040_0000にする。といってもROMもメモリも14bitしか線を用意してないので、下しか使わないが。

### beqまでの回路図を作る

本書に従い、まずはlwだけの回路を作る。

![images/2019-09-19-verilog_intro/lw.png]({{"/assets/images/2019-09-19-verilog_intro/lw.png" | absolute_url}})

おぉ、なんかこれめっちゃ楽しいな。ではswも対応してみる。

![images/2019-09-19-verilog_intro/lw_sw.png]({{"/assets/images/2019-09-19-verilog_intro/lw_sw.png" | absolute_url}})

これ、ひたすら貼っていくと凄い重いページになりそうだな。まぁいいか。

次はR形式。

![images/2019-09-19-verilog_intro/lw_sw_add.png]({{"/assets/images/2019-09-19-verilog_intro/lw_sw_add.png" | absolute_url}})

次にbeq。

![images/2019-09-19-verilog_intro/lw_sw_add_beq.png]({{"/assets/images/2019-09-19-verilog_intro/lw_sw_add_beq.png" | absolute_url}})

割とストレートに実装出来るな。

### beqまでの制御部を作る

jとかaddiも実装してみても良かったのだが、あまり制御部が無い状態で先に進むのも不安。
ここまでの制御部を作ってみるかな。

制御信号とニモニックの表を作って埋めてみよう。

![images/2019-09-19-verilog_intro/ctrl_table.png]({{"/assets/images/2019-09-19-verilog_intro/ctrl_table.png" | absolute_url}})

ALUCtrlは今の所2種類しか無いので3bitは不要ではあるが。

本文の解説を見るとaddとsubを一つにまとめて、ALUCtrlは別のテーブルを作っているな。
そっちの方が筋は良さそうだが、YAGNIの精神的には自分の方が良い気もする。

まぁいいや。とりあえずここまでは機械語から自力で作れそうに思える。