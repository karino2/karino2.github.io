---
title: System Verilogを書くぞ！
layout: page
---

[読書記録: ディジタル回路設計とコンピュータアーキテクチャ](https://karino2.github.io/2019/09/09/000435.html)を読みながら、いろいろ書いてみる時の記録。
環境設定とか適当にやってしまって記録が残ってないが、心を入れ替えてここからは記録を取る。
FPGAでLチカくらいはやった。

まずVivadoというIDEで開発していく事にする。あまりにもかったるかったらエディタでの開発環境を整えるが、ゆとりとしてはIDEでぽちぽちやりたい。

以後System Verilogを書いて行くが、面倒なのでVerilog、と記す。ゆとりなので細かい事は気にしない。

### 初めてのテストベンチ

細かなモジュールとかを書いて挙動を調べるのは、シミュレータというのでやる物らしい。
で、シミュレータではテストベンチというのを書いてモジュールをテストするらしい。

という事で、このテストベンチで何かをテストする、というのを書いてみる事から始めたい。
題材としては、書籍の4.9にテストベンチのコードがあるsillyfunctionでやってみる。

とりあえずプロジェクトを作る。
4章の演習問題を全部一つのプロジェクトに入れるのは取り回しが悪そうなので、3つくらいのプロジェクトに分けるかな。
chapter4_1というプロジェクトを作る。

次にsillyfunction.svというファイルを作り、sillyfunctionの実装をへこへこ書く。

テストベンチは普通はファイル分けるらしいが、今回は動作確認なので同じファイルでもいいかな。
ちょっと同じファイルにテストベンチも書いてみよう。

モジュール名はchapter4_1の前半で被らないように、testbench_sillyfunctionにしよう。長いがゆとりなので。

中身としてはとりあえず000と001のテストだけ書いて動かしてみよう。
どうやって動かすんだろう？

Runのアイコン（緑の右三角）を押して、Run synthesisというのを選んでみた。右上の所に Running synth_designって出てくるくる回ってる。しばらく待つか。
お、合成が成功した、と出てきて、三つの選択肢が出てきた。Run Implementationを選んでみるか。

おや、エラーになった。Design is emptyとPlacer could not place all instancesと言われた。

走らせたものが間違っているのか？なんか前はRun simulationというのを選んでビヘイビアがどうこう、とか選んだ記憶があるな。

左のペインにRun simulationというのがツリーのSimulationの中に入っているな。これを選んでみるか。
おー、出来た。波形が見れる。いいね。

少し変えてみた。ちゃんと動いてそう。よしよし。
一応failしたケースの挙動も調べておくか。`$error`というのを使っているのだが。assertをfailするように変更。

ん？何も起こらないが。
しばらく格闘した結果、Tcl consoleに出ているが流れて気づいていなかった、という結論っぽい。
`$display`というのもあるな。これは標準出力に出す、errorは標準エラー出力に出す、という所か。なるほど。

よし、これで作業を続けていけそうだな。

現状、Run Simulationとやると全テストベンチが流れてしまう。これはちと都合が悪いな。
選んで実行とかできないのだろうか？
Disable fileというのがあるな。これでテストをdisableにしておけばいいのか。

### 演習問題 4.3 xorを実装せよ

やってみよう。xorは予約語だから使えない、と言われた。myxorという名前にするか。

4入力のxor、期待する振る舞いはなんだろう？多入力ゲートは1.5.6節にあるな。
TRUEが奇数個ならTRUEを出力するらしい。

どう実装するのがいいかしら？4入力なら組み合わせは16個か？TRUEになるだけでいいので半数の8個くらいか。
この位ならcaseで書けばいい気もするな。

caseを使う場合はassignでいいんだっけ？4.5.4を見ると、caseを使う場合はブロッキング割り当てを使うのが良さそう。
それぞれの違いを軽く見直しておく。ノンブロッキングは並列に評価されるみたいな挙動か。
一応説明を読み直したが、とりあえず心を無にしてこのガイドラインに従って、always_combの時はブロッキング割り当てを使おう。

caseでは奇数でも偶数でもどちらか一つをセットすれば良い。
奇数個と偶数個はどっちが少ないか？偶数個は2個と4個。4個は一通り、2個は4C2で6通りか？
奇数個は1個と3個でどちらも4通りか。おや。偶数個の方が一つ少ない。まぁ一つくらいならいいか。

よし、出来た。
`logic [3:0] a, y;`とやったらyも4bit幅になっているというバグを入れてしまっていたが、無事デバッグも出来た。
よしよし。

### レポジトリを作ろう

進捗を見せるという点でも、githubに上げておく方が良かろう。という事でレポジトリを作りたい。
プロジェクトのディレクトリを眺めると、chapter4_1/chapter4_1.srcs/sources_1/new の下だけで良さそうか？
newってのが何なのか知らないが。

この本の英語名はなんだっけ。DDCAでいいか。ではDDCA_exerciseで行こう。
レポジトリ一つに全部入れたい気もするが、XilinxのIDEの構成と共存するのが難しいな。

シンボリックリンクを貼ったらgitはsymlinkはadd出来んと言われる。そうか。
ハードリンクなら？と思ったがハードリンクはファイルごとにやらないとダメそう。そりゃそうだな。

うーん、逆にxilinxの方のディレクトリをシンボリックリンクにしたらどうだろう？やってみよう。
mklinkコマンド、ちょくちょく出番あるよな。

よし、ちゃんと動いているね。

[https://github.com/karino2/DDCA_exercise](https://github.com/karino2/DDCA_exercise)


### 4.5 minotiry

少なくとも二つの入力がFALSEならTRUEを出力する。
という事は、~a~bc+~ab~c+a~b~c+~a~b~cか。
簡単化出来るか？~a~b~cがあるから、真の部分はいらないな。
~a~b+~a~c+~b~cか。ま、この位でいいな。

あ、Verilogはアンドと縦棒か。`~a&~b|~a&~c|~b&~c`か。
まぁブログ的にはmarkdownに優しいブール代数表記でいいか？

よし、動いた。

### 4.6 hex display

16進数のディスプレイ表示。例題2.10に10進の表示があるので、変数名などはこれをベースにする。

あれ？Bと8ってどう区別するんだ？Dと0も一緒だよな。小文字にすればいいか？
aとかは小文字だと読みにくそうだな。bとdだけ小文字にするか。

ローマ字の所での各セグメントのうち、1になる所だけ列記する。

- A abcef
- b cdefg
- C adef
- d bcdeg
- E adefg
- F aefg

こんなもんか。あとは心を無にしてそのままVerilogでずらずら項を書いて行くかな。
assignをひたすら並べていけばいいか。

aはだいたいあるから無い方を入れる方が楽か。
0になるケースを考えると~0001+~0100+~1011+~1110か。これの否定だな。

うーむ、これを`d[0]`とか`d[1]`とかで書くのはだる過ぎるな。case使うか。

あれ？記述例4.24に10進数の例があるな。モジュール名や変数名はこれに合わせるんだったなぁ。
変数名は今からでも遅くないか。
これだと7変数に一気に入れている。どうせcase使うならこっちのほうが楽か。真似しよう。

10進のコードを写経するのがだるいな。まぁこの位は修行と思って頑張るか。

これ、書いたはいいがテストって何書くんだ？入れた値が出てくる、としか書けないよなぁ。
表示できないと盛り上がらないなぁ。手元のFPGAを見たが7セグメントディスプレイは無いか。
LEDはあるが、数字が出ないと盛り上がらないよなぁ、やっぱ。

aの時だけテストして波形を見て満足したので次に行く。

### 4.8 mux8 (8:1マルチプレクサ)

前に4:1がどっかにあったなぁ、と見直すと、4.2.4の記述例4.5とか4.6でその辺をやっている。
d0とかyは3:0っぽいな。
これもcase文でずらずら書く方が早いな。というかこればっかだな。

次の4.9はy = a~b+~b~c+~abcをmux8で書け、との事。答えを全部ハードコードしろって事か？
まあ大した事無いが意味は分からんな。

次の4.10では4:1を使って書け、とある。notはいくら使っても良い、とあるが、別にmux4を3つ並べればnotは使わない気がする。
逆にそれ以外の場合、何が出来るというのか？
もともと一行で片付く論理回路をあえてmuxを使うとうい問題なので、何がOKで何がNGか良く分からないな…

その他、mux4版やpriority8なども作る。特に問題無し。

### 6:64デコーダ

2:4デコーダーを作れ、との事。
2:4ってどういう意味だっけ？と前を見直すと、2bitの値を4ビットのワンホットにデコードする、という意味らしい。
なるほど。
case文で一瞬な気がするな。やっていこう。

次に6:64デコーダを作れ、と言う。
おや、assignを64個並べれば出来るだろうが、さすがにそれは無いだろう。どうしたらいいんだろう？

とりあえず4っつくらい代入してみよう。

```
   assign y[63] = high[3] & mid[3] & low[3];
   assign y[62] = high[3] & mid[3] & low[2];
   assign y[61] = high[3] & mid[3] & low[1];
   assign y[60] = high[3] & mid[3] & low[0];
```

最後の列以外は一緒なのか。つまりブロードキャストみたいな事が出来れば良さそうだな。
条件割り当て使えば出来るのは分かるが、インストラクションはAND回路だけで出来そうな書き方だよな。

ハードの人に聞いた所、`{4{high[3]}}`みたいな書き方でいいとの事。なるほど。
ではこれを激しくやっていくとこうか？

```
    assign y = {{16{high[3]}}, {16{high[2]}}, {16{high[1]}}, {16{high[0]}}} &
         {4{{4{mid[3]}}, {4{mid[2]}}, {4{mid[1]}}, {4{mid[0]}}}} & {16{low[3:0]}};

```

相当激しい感じだが、なんか動いている風味だ。

## ここまでで4章の演習問題は良しとしよう

だいたいVerilogのコード書き溜めとしては十分なくらい出来たし、デバッグ回りや波形の見方、IDEの使い方なども慣れてきたので、ここでやるべき事はマスターしたといえるだろう。
まだまだ演習問題はあるが、ここまでで次に進もう。